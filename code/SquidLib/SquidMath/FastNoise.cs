// FastNoise.cs
//
// MIT License
//
// Copyright(c) 2017 Jordan Peck
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// The developer's email is jorzixdan.me2@gzixmail.com (for great email, take
// off every 'zix'.)
//

using System;
using System.Runtime.CompilerServices;
using static SquidLib.SquidMath.CoreMath;

namespace SquidLib.SquidMath {
    public class FastNoise {
        private const short FN_INLINE = 256; //(Int16)MethodImplOptions.AggressiveInlining;
        private const int FN_CELLULAR_INDEX_MAX = 3;

        public enum NoiseType { Value, ValueFractal, Perlin, PerlinFractal, Simplex, SimplexFractal, Cellular, WhiteNoise, Cubic, CubicFractal };
        public enum Interp { Linear, Hermite, Quintic };
        public enum FractalType { FBM, Billow, Ridged };
        public enum CellularDistanceFunction { Euclidean, Manhattan, Natural };
        public enum CellularReturnType { CellValue, NoiseLookup, Distance, Distance2, Distance2Add, Distance2Sub, Distance2Mul, Distance2Div };

        private int seed = 1337;
        private double frequency = 0.01;
        private Interp interp = Interp.Quintic;
        private NoiseType noiseType = NoiseType.Simplex;

        private int octaves = 3;
        private double lacunarity = 2.0;
        private double gain = 0.5;
        private FractalType fractalType = FractalType.FBM;

        private double fractalBounding;

        private CellularDistanceFunction cellularDistanceFunction = CellularDistanceFunction.Euclidean;
        private CellularReturnType cellularReturnType = CellularReturnType.CellValue;
        private FastNoise cellularNoiseLookup = null;
        private int cellularDistanceIndex0 = 0;
        private int cellularDistanceIndex1 = 1;
        private float cellularJitter = 0.45f;

        private double gradientPerturbAmp = 1.0;

        public FastNoise(int seed = 1337) {
            this.seed = seed;
            CalculateFractalBounding();
        }

        // Returns the seed used by this object
        public int GetSeed() => seed;

        // Sets seed used for all noise types
        // Default: 1337
        public void SetSeed(int seed) => this.seed = seed;

        // Sets frequency for all noise types
        // Default: 0.01
        public void SetFrequency(double frequency) => this.frequency = frequency;

        // Changes the interpolation method used to smooth between noise values
        // Possible interpolation methods (lowest to highest quality) :
        // - Linear
        // - Hermite
        // - Quintic
        // Used in Value, Gradient Noise and Position Perturbing
        // Default: Quintic
        public void SetInterp(Interp interp) => this.interp = interp;

        // Sets noise return type of GetNoise(...)
        // Default: Simplex
        public void SetNoiseType(NoiseType noiseType) => this.noiseType = noiseType;


        // Sets octave count for all fractal noise types
        // Default: 3
        public void SetFractalOctaves(int octaves) { this.octaves = octaves; CalculateFractalBounding(); }

        // Sets octave lacunarity for all fractal noise types
        // Default: 2.0
        public void SetFractalLacunarity(double lacunarity) => this.lacunarity = lacunarity;

        // Sets octave gain for all fractal noise types
        // Default: 0.5
        public void SetFractalGain(double gain) { this.gain = gain; CalculateFractalBounding(); }

        // Sets method for combining octaves in all fractal noise types
        // Default: FBM
        public void SetFractalType(FractalType fractalType) => this.fractalType = fractalType;


        // Sets return type from cellular noise calculations
        // Note: NoiseLookup requires another FastNoise object be set with SetCellularNoiseLookup() to function
        // Default: CellValue
        public void SetCellularDistanceFunction(CellularDistanceFunction cellularDistanceFunction) => this.cellularDistanceFunction = cellularDistanceFunction;

        // Sets distance function used in cellular noise calculations
        // Default: Euclidean
        public void SetCellularReturnType(CellularReturnType cellularReturnType) => this.cellularReturnType = cellularReturnType;

        // Sets the 2 distance indicies used for distance2 return types
        // Default: 0, 1
        // Note: index0 should be lower than index1
        // Both indicies must be >= 0, index1 must be < 4
        public void SetCellularDistance2Indicies(int cellularDistanceIndex0, int cellularDistanceIndex1) {
            this.cellularDistanceIndex0 = Math.Min(cellularDistanceIndex0, cellularDistanceIndex1);
            this.cellularDistanceIndex1 = Math.Max(cellularDistanceIndex0, cellularDistanceIndex1);

            this.cellularDistanceIndex0 = Math.Min(Math.Max(this.cellularDistanceIndex0, 0), FN_CELLULAR_INDEX_MAX);
            this.cellularDistanceIndex1 = Math.Min(Math.Max(this.cellularDistanceIndex1, 0), FN_CELLULAR_INDEX_MAX);
        }

        // Sets the maximum distance a cellular point can move from it's grid position
        // Setting this high will make artifacts more common
        // Default: 0.45
        public void SetCellularJitter(float cellularJitter) => this.cellularJitter = cellularJitter;

        // Noise used to calculate a cell value if cellular return type is NoiseLookup
        // The lookup value is acquired through GetNoise() so ensure you SetNoiseType() on the noise lookup, value, gradient or simplex is recommended
        public void SetCellularNoiseLookup(FastNoise noise) => cellularNoiseLookup = noise;


        // Sets the maximum perturb distance from original location when using GradientPerturb{Fractal}(...)
        // Default: 1.0
        public void SetGradientPerturbAmp(double gradientPerturbAmp) => this.gradientPerturbAmp = gradientPerturbAmp;

        private struct Float2 {
            public readonly double x, y;
            public Float2(double x, double y) {
                this.x = x;
                this.y = y;
            }
        }

        private struct Float3 {
            public readonly double x, y, z;
            public Float3(float x, float y, float z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            public Float3(double x, double y, double z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }

        #region CONSTANTS

        //private static readonly Float2[] GRAD2D = {
        //new Float2(-1,-1), new Float2( 1,-1), new Float2(-1, 1), new Float2( 1, 1),
        //new Float2( 0,-1), new Float2(-1, 0), new Float2( 0, 1), new Float2( 1, 0),
        //};

        //    private static readonly Float3[] GRAD_3D = {
        //    new Float3( 1, 1, 0), new Float3(-1, 1, 0), new Float3( 1,-1, 0), new Float3(-1,-1, 0),
        //    new Float3( 1, 0, 1), new Float3(-1, 0, 1), new Float3( 1, 0,-1), new Float3(-1, 0,-1),
        //    new Float3( 0, 1, 1), new Float3( 0,-1, 1), new Float3( 0, 1,-1), new Float3( 0,-1,-1),
        //    new Float3( 1, 1, 0), new Float3( 0,-1, 1), new Float3(-1, 1, 0), new Float3( 0,-1,-1),
        //};

        private static readonly double[] GRAD_2D = {
            0.6499429579167653, 0.759982994187637,
            -0.1551483029088119, 0.9878911904175052,
            -0.8516180517334043, 0.5241628506120981,
            -0.9518580082090311, -0.30653928330368374,
            -0.38568876701087174, -0.9226289476282616,
            0.4505066120763985, -0.8927730912586049,
            0.9712959670388622, -0.23787421973396244,
            0.8120673355833279, 0.5835637432865366,
            0.08429892519436613, 0.9964405106232257,
            -0.702488350003267, 0.7116952424385647,
            -0.9974536374007479, -0.07131788861160528,
            -0.5940875849508908, -0.804400361391775,
            0.2252075529515288, -0.9743108118529653,
            0.8868317111719171, -0.4620925405802277,
            0.9275724981153959, 0.373643226540993,
            0.3189067150428103, 0.9477861083074618,
            -0.5130301507665112, 0.8583705868705491,
            -0.9857873824221494, 0.1679977281313266,
            -0.7683809836504446, -0.6399927061806058,
            -0.013020236219374872, -0.9999152331316848,
            0.7514561619680513, -0.6597830223946701,
            0.9898275175279653, 0.14227257481477412,
            0.5352066871710182, 0.8447211386057674,
            -0.29411988281443646, 0.9557685360657266,
            -0.9175289804081126, 0.39766892022290273,
            -0.8985631161871687, -0.43884430750324743,
            -0.2505005588110731, -0.968116454790094,
            0.5729409678802212, -0.8195966369650838,
            0.9952584535626074, -0.09726567026534665,
            0.7207814785200723, 0.6931623620930514,
            -0.05832476124070039, 0.998297662136006,
            -0.7965970142012075, 0.6045107087270838,
            -0.977160478114496, -0.21250270589112422,
            -0.4736001288089817, -0.8807399831914728,
            0.36153434093875386, -0.9323587937709286,
            0.9435535266854258, -0.3312200813348966,
            0.8649775992346886, 0.5018104750024599,
            0.1808186720712497, 0.9835164502083277,
            -0.6299339540895539, 0.7766487066139361,
            -0.9996609468975833, 0.02603826506945166,
            -0.6695112313914258, -0.7428019325774111,
            0.12937272671950842, -0.9915960354807594,
            0.8376810167470904, -0.5461597881403947,
            0.959517028911149, 0.28165061908243916,
            0.4095816551369482, 0.9122734610714476,
            -0.42710760401484793, 0.9042008043530463,
            -0.9647728141412515, 0.2630844295924223,
            -0.8269869890664444, -0.562221059650754,
            -0.11021592552380209, -0.9939076666174438,
            0.6837188597775012, -0.72974551782423,
            0.998972441738333, 0.04532174585508431,
            0.6148313475439905, 0.7886586169422362,
            -0.1997618324529528, 0.9798444827088829,
            -0.8744989400706802, 0.48502742583822706,
            -0.9369870231562731, -0.3493641630687752,
            -0.3434772946489506, -0.9391609809082988,
            0.4905057254335028, -0.8714379687143274,
            0.9810787787756657, -0.1936089611460388,
            0.7847847614201463, 0.6197684069414349,
            0.03905187955516296, 0.9992371844077906,
            -0.7340217731995672, 0.6791259356474049,
            -0.9931964444524306, -0.1164509455824639,
            -0.5570202966000876, -0.830498879695542,
            0.2691336060685578, -0.9631028512493016,
            0.9068632806061, -0.4214249521425399,
            0.9096851999779008, 0.4152984913783901,
            0.27562369868737335, 0.9612656119522284,
            -0.5514058359842319, 0.8342371389734039,
            -0.9923883787916933, 0.12314749546456379,
            -0.7385858406439617, -0.6741594440488484,
            0.032311046904542805, -0.9994778618098213,
            0.7805865154410089, -0.6250477517051506,
            0.9823623706068018, 0.18698709264487903,
            0.49637249435561115, 0.8681096398768929,
            -0.3371347561867868, 0.9414564016304079,
            -0.9346092156607797, 0.35567627697379833,
            -0.877750600058892, -0.47911781859606817,
            -0.20636642697019966, -0.9784747813917093,
            0.6094977881394418, -0.7927877687333024,
            0.998644017504346, -0.052058873429796634,
            0.6886255051458764, 0.7251171723677399,
            -0.10350942208147358, 0.9946284731196666,
            -0.8231759450656516, 0.567786371327519,
            -0.9665253951623188, -0.2565709658288005,
            -0.43319680340129196, -0.9012993562201753,
            0.4034189716368784, -0.9150153732716426,
            0.9575954428121146, -0.28811624026678895,
            0.8413458575409575, 0.5404971304259356,
            0.13605818775026976, 0.9907008476558967,
            -0.664485735550556, 0.7473009482463117,
            -0.999813836664718, -0.01929487014147803,
            -0.6351581891853917, -0.7723820781910558,
            0.17418065221630152, -0.984713714941304,
            0.8615731658120597, -0.5076334109892543,
            0.945766171482902, 0.32484819358982736,
            0.3678149601703667, 0.9298990026206456,
            -0.4676486851245607, 0.883914423064399,
            -0.9757048995218635, 0.2190889067228882,
            -0.8006563717736747, -0.5991238388999518,
            -0.06505704156910719, -0.9978815467490495,
            0.716089639712196, -0.6980083293893113,
            0.9958918787052943, 0.09055035024139549,
            0.5784561871098056, 0.8157134543418942,
            -0.24396482815448167, 0.9697840804135497,
            -0.8955826311865743, 0.4448952131872543,
            -0.9201904205900768, -0.39147105876968413,
            -0.3005599364234082, -0.9537629289384008,
            0.5294967923694863, -0.84831193960148,
            0.9888453593035162, -0.1489458135829932,
            0.7558893631265085, 0.6546993743025888,
            -0.006275422246980369, 0.9999803093439501,
            -0.764046696121276, 0.6451609459244744,
            -0.9868981170802014, -0.16134468229090512,
            -0.5188082666339063, -0.8548906260290385,
            0.31250655826478446, -0.9499156020623616,
            0.9250311403279032, -0.3798912863223621,
            0.889928392754896, 0.45610026942404636,
            0.2317742435145519, 0.9727696027545563,
            -0.5886483179573486, 0.8083892365475831,
            -0.996949901406418, 0.0780441803450664,
            -0.707272817672466, -0.7069407057042696,
            0.07757592706207364, -0.9969864470194466,
            0.8081126726681943, -0.5890279350532263,
            0.9728783545459001, 0.23131733021125322,
            0.4565181982253288, 0.8897140746830408,
            -0.3794567783511009, 0.9252094645881026,
            -0.9497687200714887, 0.31295267753091066,
            -0.8551342041690687, -0.5184066867432686,
            -0.16180818807538452, -0.9868222283024238,
            0.6448020194233159, -0.7643496292585048,
            0.9999772516247822, -0.006745089543285545,
            0.6550543261176665, 0.7555817823601425,
            -0.14848135899860646, 0.9889152066936411,
            -0.848063153443784, 0.5298951667745091,
            -0.9539039899003245, -0.300111942535184,
            -0.3919032080850608, -0.9200064540494471,
            0.44447452934057863, -0.8957914895596358,
            0.9696693887216105, -0.24442028675267172,
            0.8159850520735595, 0.5780730012658526,
            0.0910180879994953, 0.9958492394217692,
            -0.6976719213969089, 0.7164173993520435,
            -0.9979119924958648, -0.06458835214597858,
            -0.5994998228898376, -0.8003748886334786,
            0.2186306161766729, -0.9758076929755208,
            0.8836946816279001, -0.46806378802740584,
            0.9300716543684309, 0.36737816720699407,
            0.32529236260160294, 0.9456134933645286,
            -0.5072286936943775, 0.8618114946396893,
            -0.9846317976415725, 0.17464313062106204,
            -0.7726803123417516, -0.6347953488483143,
            -0.019764457813331488, -0.9998046640256011,
            0.7469887719961158, -0.6648366525032559,
            0.9907646418168752, 0.13559286310672486,
            0.5408922318074902, 0.8410919055432124,
            -0.2876664477065717, 0.9577306588304888,
            -0.9148257956391065, 0.40384868903250853,
            -0.9015027194859215, -0.4327734358292892,
            -0.2570248925062563, -0.9664047830139022,
            0.5673996816983953, -0.8234425306046317,
            0.9945797473944409, -0.10397656501736473,
            0.7254405241129018, 0.6882848581617921,
            -0.05158982732517303, 0.9986683582233687,
            -0.7925014140531963, 0.609870075281354,
            -0.9785715990807187, -0.20590683687679034,
            -0.47953002522651733, -0.8775254725113429,
            0.35523727306945746, -0.9347761656258549,
            0.9412979532686209, -0.33757689964259285,
            0.868342678987353, 0.4959647082697184,
            0.18744846526420056, 0.9822744386728669,
            -0.6246810590458048, 0.7808800000444446,
            -0.9994625758058275, 0.03278047534097766,
            -0.674506266646887, -0.738269121834361,
            0.12268137965007223, -0.9924461089082646,
            0.8339780641890598, -0.5517975973592748,
            0.9613949601033843, 0.2751721837101493,
            0.41572570400265835, 0.9094900433932711,
            -0.42099897262033487, 0.907061114287578,
            -0.9629763390922247, 0.2695859238694348,
            -0.8307604078465821, -0.5566301687427484,
            -0.11691741449967302, -0.9931416405461567,
            0.6787811074228051, -0.7343406622310046,
            0.999255415972447, 0.03858255628819732,
            0.6201369341201711, 0.7844935837468874,
            -0.19314814942146824, 0.9811696042861612,
            -0.8712074932224428, 0.4909149659086258,
            -0.9393222007870077, -0.34303615422962713,
            -0.3498042060103595, -0.9368228314134226,
            0.4846166400948296, -0.8747266499559725,
            0.9797505510481769, -0.20022202106859724,
            0.7889473022428521, 0.6144608647291752,
            0.045790935472179155, 0.9989510449609544,
            -0.7294243101497431, 0.684061529222753,
            -0.9939593229024027, -0.10974909756074072,
            -0.562609414602539, -0.8267228354174018,
            0.26263126874523307, -0.9648962724963078,
            0.9040001019019392, -0.4275322394408211,
            0.9124657316291773, 0.4091531358824348,
            0.28210125132356934, 0.9593846381935018,
            -0.5457662881946498, 0.8379374431723614,
            -0.9915351626845509, 0.12983844253579577,
            -0.7431163048326799, -0.6691622803863227,
            0.02556874420628532, -0.9996730662170076,
            0.7763527553119807, -0.6302986588273021,
            0.9836012681423212, 0.1803567168386515,
            0.5022166799422209, 0.8647418148718223,
            -0.330776879188771, 0.9437089891455613,
            -0.9321888864830543, 0.3619722087639923,
            -0.8809623252471085, -0.47318641305008735,
            -0.21296163248563432, -0.9770605626515961,
            0.604136498566135, -0.7968808512571063,
            0.9982701582127194, -0.05879363249495786,
            0.6935008202914851, 0.7204558364362367,
            -0.09679820929680796, 0.9953040272584711,
            -0.8193274492343137, 0.5733258505694586,
            -0.9682340024187017, -0.25004582891994304,
            -0.4392662937408502, -0.8983569018954422,
            0.39723793388455464, -0.9177156552457467,
            0.9556302892322005, -0.2945687530984589,
            0.8449724198323217, 0.5348098818484104,
            0.14273745857559722, 0.9897605861618151,
            -0.6594300077680133, 0.7517659641504648,
            -0.9999212381512442, -0.01255059735959867,
            -0.6403535266476091, -0.768080308893523,
            0.16753470770767478, -0.9858661784001437,
            0.8581295336101056, -0.5134332513054668,
            0.9479357869928937, 0.31846152630759517,
            0.37407884501651706, 0.9273969040875156,
            -0.461675964944643, 0.8870486477034012,
            -0.9742049295269273, 0.22566513972130173,
            -0.8046793020829978, -0.5937097108850584,
            -0.07178636201352963, -0.9974200309943962,
            0.7113652211526822, -0.7028225395748172,
            0.9964799940037152, 0.08383091047075403,
            0.5839450884626246, 0.8117931594072332,
            -0.23741799789097484, 0.9714075840127259,
            -0.8925614000865144, 0.45092587758477687,
            -0.9228099950981292, -0.38525538665538556,
            -0.30698631553196837, -0.95171392869712,
            0.5237628071845146, -0.8518641451605984,
            0.9878182118285335, -0.15561227580071732,
            0.7602881737752754, 0.6495859395164404,
            4.6967723669845613E-4, 0.9999998897016406,
            -0.7596776469502666, 0.6502998329417794,
            -0.9879639510809196, -0.15468429579171308,
            -0.5245627784110601, -0.8513717704420726,
            0.3060921834538644, -0.9520018777441807,
            0.9224476966294768, -0.3861220622846781,
            0.8929845854878761, 0.45008724718774934,
            0.23833038910266038, 0.9711841358002995,
            -0.5831822693781987, 0.8123413326200348,
            -0.9964008074312266, 0.0847669213219385,
            -0.712025106726807, -0.7021540054650968,
            0.07084939947717452, -0.9974870237721009,
            0.8041212432524677, -0.5944653279629567,
            0.9744164792492415, 0.22474991650168097,
            0.462509014279733, 0.8866145790082576,
        };

        private static readonly Float3[] GRAD_3D = {
                    new Float3(-0.448549002408981,  1.174316525459290,  0.000000000000001),
                    new Float3( 0.000000000000001,  1.069324374198914,  0.660878777503967),
                    new Float3( 0.448549002408981,  1.174316525459290,  0.000000000000001),
                    new Float3( 0.000000000000001,  1.069324374198914, -0.660878777503967),
                    new Float3(-0.725767493247986,  0.725767493247986, -0.725767493247986),
                    new Float3(-1.069324374198914,  0.660878777503967,  0.000000000000001),
                    new Float3(-0.725767493247986,  0.725767493247986,  0.725767493247986),
                    new Float3( 0.725767493247986,  0.725767493247986,  0.725767493247986),
                    new Float3( 1.069324374198914,  0.660878777503967,  0.000000000000000),
                    new Float3( 0.725767493247986,  0.725767493247986, -0.725767493247986),
                    new Float3(-0.660878777503967,  0.000000000000003, -1.069324374198914),
                    new Float3(-1.174316525459290,  0.000000000000003, -0.448549002408981),
                    new Float3( 0.000000000000000,  0.448549002408981, -1.174316525459290),
                    new Float3(-0.660878777503967,  0.000000000000001,  1.069324374198914),
                    new Float3( 0.000000000000001,  0.448549002408981,  1.174316525459290),
                    new Float3(-1.174316525459290,  0.000000000000001,  0.448549002408981),
                    new Float3( 0.660878777503967,  0.000000000000001,  1.069324374198914),
                    new Float3( 1.174316525459290,  0.000000000000001,  0.448549002408981),
                    new Float3( 0.660878777503967,  0.000000000000001, -1.069324374198914),
                    new Float3( 1.174316525459290,  0.000000000000001, -0.448549002408981),
                    new Float3(-0.725767493247986, -0.725767493247986, -0.725767493247986),
                    new Float3(-1.069324374198914, -0.660878777503967, -0.000000000000001),
                    new Float3(-0.000000000000001, -0.448549002408981, -1.174316525459290),
                    new Float3(-0.000000000000001, -0.448549002408981,  1.174316525459290),
                    new Float3(-0.725767493247986, -0.725767493247986,  0.725767493247986),
                    new Float3( 0.725767493247986, -0.725767493247986,  0.725767493247986),
                    new Float3( 1.069324374198914, -0.660878777503967,  0.000000000000001),
                    new Float3( 0.725767493247986, -0.725767493247986, -0.725767493247986),
                    new Float3(-0.000000000000004, -1.069324374198914, -0.660878777503967),
                    new Float3(-0.448549002408981, -1.174316525459290, -0.000000000000003),
                    new Float3(-0.000000000000003, -1.069324374198914,  0.660878777503967),
                    new Float3( 0.448549002408981, -1.174316525459290,  0.000000000000003),
        };

        private static readonly double[] GRAD_4D =             {
                    -0.5875167, 1.4183908, 1.4183908, 1.4183908,
                    -0.5875167, 1.4183908, 1.4183908, -1.4183908,
                    -0.5875167, 1.4183908, -1.4183908, 1.4183908,
                    -0.5875167, 1.4183908, -1.4183908, -1.4183908,
                    -0.5875167, -1.4183908, 1.4183908, 1.4183908,
                    -0.5875167, -1.4183908, 1.4183908, -1.4183908,
                    -0.5875167, -1.4183908, -1.4183908, 1.4183908,
                    -0.5875167, -1.4183908, -1.4183908, -1.4183908,
                    1.4183908, -0.5875167, 1.4183908, 1.4183908,
                    1.4183908, -0.5875167, 1.4183908, -1.4183908,
                    1.4183908, -0.5875167, -1.4183908, 1.4183908,
                    1.4183908, -0.5875167, -1.4183908, -1.4183908,
                    -1.4183908, -0.5875167, 1.4183908, 1.4183908,
                    -1.4183908, -0.5875167, 1.4183908, -1.4183908,
                    -1.4183908, -0.5875167, -1.4183908, 1.4183908,
                    -1.4183908, -0.5875167, -1.4183908, -1.4183908,
                    1.4183908, 1.4183908, -0.5875167, 1.4183908,
                    1.4183908, 1.4183908, -0.5875167, -1.4183908,
                    1.4183908, -1.4183908, -0.5875167, 1.4183908,
                    1.4183908, -1.4183908, -0.5875167, -1.4183908,
                    -1.4183908, 1.4183908, -0.5875167, 1.4183908,
                    -1.4183908, 1.4183908, -0.5875167, -1.4183908,
                    -1.4183908, -1.4183908, -0.5875167, 1.4183908,
                    -1.4183908, -1.4183908, -0.5875167, -1.4183908,
                    1.4183908, 1.4183908, 1.4183908, -0.5875167,
                    1.4183908, 1.4183908, -1.4183908, -0.5875167,
                    1.4183908, -1.4183908, 1.4183908, -0.5875167,
                    1.4183908, -1.4183908, -1.4183908, -0.5875167,
                    -1.4183908, 1.4183908, 1.4183908, -0.5875167,
                    -1.4183908, 1.4183908, -1.4183908, -0.5875167,
                    -1.4183908, -1.4183908, 1.4183908, -0.5875167,
                    -1.4183908, -1.4183908, -1.4183908, -0.5875167,
                    0.5875167, 1.4183908, 1.4183908, 1.4183908,
                    0.5875167, 1.4183908, 1.4183908, -1.4183908,
                    0.5875167, 1.4183908, -1.4183908, 1.4183908,
                    0.5875167, 1.4183908, -1.4183908, -1.4183908,
                    0.5875167, -1.4183908, 1.4183908, 1.4183908,
                    0.5875167, -1.4183908, 1.4183908, -1.4183908,
                    0.5875167, -1.4183908, -1.4183908, 1.4183908,
                    0.5875167, -1.4183908, -1.4183908, -1.4183908,
                    1.4183908, 0.5875167, 1.4183908, 1.4183908,
                    1.4183908, 0.5875167, 1.4183908, -1.4183908,
                    1.4183908, 0.5875167, -1.4183908, 1.4183908,
                    1.4183908, 0.5875167, -1.4183908, -1.4183908,
                    -1.4183908, 0.5875167, 1.4183908, 1.4183908,
                    -1.4183908, 0.5875167, 1.4183908, -1.4183908,
                    -1.4183908, 0.5875167, -1.4183908, 1.4183908,
                    -1.4183908, 0.5875167, -1.4183908, -1.4183908,
                    1.4183908, 1.4183908, 0.5875167, 1.4183908,
                    1.4183908, 1.4183908, 0.5875167, -1.4183908,
                    1.4183908, -1.4183908, 0.5875167, 1.4183908,
                    1.4183908, -1.4183908, 0.5875167, -1.4183908,
                    -1.4183908, 1.4183908, 0.5875167, 1.4183908,
                    -1.4183908, 1.4183908, 0.5875167, -1.4183908,
                    -1.4183908, -1.4183908, 0.5875167, 1.4183908,
                    -1.4183908, -1.4183908, 0.5875167, -1.4183908,
                    1.4183908, 1.4183908, 1.4183908, 0.5875167,
                    1.4183908, 1.4183908, -1.4183908, 0.5875167,
                    1.4183908, -1.4183908, 1.4183908, 0.5875167,
                    1.4183908, -1.4183908, -1.4183908, 0.5875167,
                    -1.4183908, 1.4183908, 1.4183908, 0.5875167,
                    -1.4183908, 1.4183908, -1.4183908, 0.5875167,
                    -1.4183908, -1.4183908, 1.4183908, 0.5875167,
                    -1.4183908, -1.4183908, -1.4183908, 0.5875167,
            };


        private static readonly Float2[] CELL_2D = {
        new Float2(-0.2700222198f, -0.9628540911f), new Float2(0.3863092627f, -0.9223693152f), new Float2(0.04444859006f, -0.999011673f), new Float2(-0.5992523158f, -0.8005602176f), new Float2(-0.7819280288f, 0.6233687174f), new Float2(0.9464672271f, 0.3227999196f), new Float2(-0.6514146797f, -0.7587218957f), new Float2(0.9378472289f, 0.347048376f),
        new Float2(-0.8497875957f, -0.5271252623f), new Float2(-0.879042592f, 0.4767432447f), new Float2(-0.892300288f, -0.4514423508f), new Float2(-0.379844434f, -0.9250503802f), new Float2(-0.9951650832f, 0.0982163789f), new Float2(0.7724397808f, -0.6350880136f), new Float2(0.7573283322f, -0.6530343002f), new Float2(-0.9928004525f, -0.119780055f),
        new Float2(-0.0532665713f, 0.9985803285f), new Float2(0.9754253726f, -0.2203300762f), new Float2(-0.7665018163f, 0.6422421394f), new Float2(0.991636706f, 0.1290606184f), new Float2(-0.994696838f, 0.1028503788f), new Float2(-0.5379205513f, -0.84299554f), new Float2(0.5022815471f, -0.8647041387f), new Float2(0.4559821461f, -0.8899889226f),
        new Float2(-0.8659131224f, -0.5001944266f), new Float2(0.0879458407f, -0.9961252577f), new Float2(-0.5051684983f, 0.8630207346f), new Float2(0.7753185226f, -0.6315704146f), new Float2(-0.6921944612f, 0.7217110418f), new Float2(-0.5191659449f, -0.8546734591f), new Float2(0.8978622882f, -0.4402764035f), new Float2(-0.1706774107f, 0.9853269617f),
        new Float2(-0.9353430106f, -0.3537420705f), new Float2(-0.9992404798f, 0.03896746794f), new Float2(-0.2882064021f, -0.9575683108f), new Float2(-0.9663811329f, 0.2571137995f), new Float2(-0.8759714238f, -0.4823630009f), new Float2(-0.8303123018f, -0.5572983775f), new Float2(0.05110133755f, -0.9986934731f), new Float2(-0.8558373281f, -0.5172450752f),
        new Float2(0.09887025282f, 0.9951003332f), new Float2(0.9189016087f, 0.3944867976f), new Float2(-0.2439375892f, -0.9697909324f), new Float2(-0.8121409387f, -0.5834613061f), new Float2(-0.9910431363f, 0.1335421355f), new Float2(0.8492423985f, -0.5280031709f), new Float2(-0.9717838994f, -0.2358729591f), new Float2(0.9949457207f, 0.1004142068f),
        new Float2(0.6241065508f, -0.7813392434f), new Float2(0.662910307f, 0.7486988212f), new Float2(-0.7197418176f, 0.6942418282f), new Float2(-0.8143370775f, -0.5803922158f), new Float2(0.104521054f, -0.9945226741f), new Float2(-0.1065926113f, -0.9943027784f), new Float2(0.445799684f, -0.8951327509f), new Float2(0.105547406f, 0.9944142724f),
        new Float2(-0.992790267f, 0.1198644477f), new Float2(-0.8334366408f, 0.552615025f), new Float2(0.9115561563f, -0.4111755999f), new Float2(0.8285544909f, -0.5599084351f), new Float2(0.7217097654f, -0.6921957921f), new Float2(0.4940492677f, -0.8694339084f), new Float2(-0.3652321272f, -0.9309164803f), new Float2(-0.9696606758f, 0.2444548501f),
        new Float2(0.08925509731f, -0.996008799f), new Float2(0.5354071276f, -0.8445941083f), new Float2(-0.1053576186f, 0.9944343981f), new Float2(-0.9890284586f, 0.1477251101f), new Float2(0.004856104961f, 0.9999882091f), new Float2(0.9885598478f, 0.1508291331f), new Float2(0.9286129562f, -0.3710498316f), new Float2(-0.5832393863f, -0.8123003252f),
        new Float2(0.3015207509f, 0.9534596146f), new Float2(-0.9575110528f, 0.2883965738f), new Float2(0.9715802154f, -0.2367105511f), new Float2(0.229981792f, 0.9731949318f), new Float2(0.955763816f, -0.2941352207f), new Float2(0.740956116f, 0.6715534485f), new Float2(-0.9971513787f, -0.07542630764f), new Float2(0.6905710663f, -0.7232645452f),
        new Float2(-0.290713703f, -0.9568100872f), new Float2(0.5912777791f, -0.8064679708f), new Float2(-0.9454592212f, -0.325740481f), new Float2(0.6664455681f, 0.74555369f), new Float2(0.6236134912f, 0.7817328275f), new Float2(0.9126993851f, -0.4086316587f), new Float2(-0.8191762011f, 0.5735419353f), new Float2(-0.8812745759f, -0.4726046147f),
        new Float2(0.9953313627f, 0.09651672651f), new Float2(0.9855650846f, -0.1692969699f), new Float2(-0.8495980887f, 0.5274306472f), new Float2(0.6174853946f, -0.7865823463f), new Float2(0.8508156371f, 0.52546432f), new Float2(0.9985032451f, -0.05469249926f), new Float2(0.1971371563f, -0.9803759185f), new Float2(0.6607855748f, -0.7505747292f),
        new Float2(-0.03097494063f, 0.9995201614f), new Float2(-0.6731660801f, 0.739491331f), new Float2(-0.7195018362f, -0.6944905383f), new Float2(0.9727511689f, 0.2318515979f), new Float2(0.9997059088f, -0.0242506907f), new Float2(0.4421787429f, -0.8969269532f), new Float2(0.9981350961f, -0.061043673f), new Float2(-0.9173660799f, -0.3980445648f),
        new Float2(-0.8150056635f, -0.5794529907f), new Float2(-0.8789331304f, 0.4769450202f), new Float2(0.0158605829f, 0.999874213f), new Float2(-0.8095464474f, 0.5870558317f), new Float2(-0.9165898907f, -0.3998286786f), new Float2(-0.8023542565f, 0.5968480938f), new Float2(-0.5176737917f, 0.8555780767f), new Float2(-0.8154407307f, -0.5788405779f),
        new Float2(0.4022010347f, -0.9155513791f), new Float2(-0.9052556868f, -0.4248672045f), new Float2(0.7317445619f, 0.6815789728f), new Float2(-0.5647632201f, -0.8252529947f), new Float2(-0.8403276335f, -0.5420788397f), new Float2(-0.9314281527f, 0.363925262f), new Float2(0.5238198472f, 0.8518290719f), new Float2(0.7432803869f, -0.6689800195f),
        new Float2(-0.985371561f, -0.1704197369f), new Float2(0.4601468731f, 0.88784281f), new Float2(0.825855404f, 0.5638819483f), new Float2(0.6182366099f, 0.7859920446f), new Float2(0.8331502863f, -0.553046653f), new Float2(0.1500307506f, 0.9886813308f), new Float2(-0.662330369f, -0.7492119075f), new Float2(-0.668598664f, 0.743623444f),
        new Float2(0.7025606278f, 0.7116238924f), new Float2(-0.5419389763f, -0.8404178401f), new Float2(-0.3388616456f, 0.9408362159f), new Float2(0.8331530315f, 0.5530425174f), new Float2(-0.2989720662f, -0.9542618632f), new Float2(0.2638522993f, 0.9645630949f), new Float2(0.124108739f, -0.9922686234f), new Float2(-0.7282649308f, -0.6852956957f),
        new Float2(0.6962500149f, 0.7177993569f), new Float2(-0.9183535368f, 0.3957610156f), new Float2(-0.6326102274f, -0.7744703352f), new Float2(-0.9331891859f, -0.359385508f), new Float2(-0.1153779357f, -0.9933216659f), new Float2(0.9514974788f, -0.3076565421f), new Float2(-0.08987977445f, -0.9959526224f), new Float2(0.6678496916f, 0.7442961705f),
        new Float2(0.7952400393f, -0.6062947138f), new Float2(-0.6462007402f, -0.7631674805f), new Float2(-0.2733598753f, 0.9619118351f), new Float2(0.9669590226f, -0.254931851f), new Float2(-0.9792894595f, 0.2024651934f), new Float2(-0.5369502995f, -0.8436138784f), new Float2(-0.270036471f, -0.9628500944f), new Float2(-0.6400277131f, 0.7683518247f),
        new Float2(-0.7854537493f, -0.6189203566f), new Float2(0.06005905383f, -0.9981948257f), new Float2(-0.02455770378f, 0.9996984141f), new Float2(-0.65983623f, 0.751409442f), new Float2(-0.6253894466f, -0.7803127835f), new Float2(-0.6210408851f, -0.7837781695f), new Float2(0.8348888491f, 0.5504185768f), new Float2(-0.1592275245f, 0.9872419133f),
        new Float2(0.8367622488f, 0.5475663786f), new Float2(-0.8675753916f, -0.4973056806f), new Float2(-0.2022662628f, -0.9793305667f), new Float2(0.9399189937f, 0.3413975472f), new Float2(0.9877404807f, -0.1561049093f), new Float2(-0.9034455656f, 0.4287028224f), new Float2(0.1269804218f, -0.9919052235f), new Float2(-0.3819600854f, 0.924178821f),
        new Float2(0.9754625894f, 0.2201652486f), new Float2(-0.3204015856f, -0.9472818081f), new Float2(-0.9874760884f, 0.1577687387f), new Float2(0.02535348474f, -0.9996785487f), new Float2(0.4835130794f, -0.8753371362f), new Float2(-0.2850799925f, -0.9585037287f), new Float2(-0.06805516006f, -0.99768156f), new Float2(-0.7885244045f, -0.6150034663f),
        new Float2(0.3185392127f, -0.9479096845f), new Float2(0.8880043089f, 0.4598351306f), new Float2(0.6476921488f, -0.7619021462f), new Float2(0.9820241299f, 0.1887554194f), new Float2(0.9357275128f, -0.3527237187f), new Float2(-0.8894895414f, 0.4569555293f), new Float2(0.7922791302f, 0.6101588153f), new Float2(0.7483818261f, 0.6632681526f),
        new Float2(-0.7288929755f, -0.6846276581f), new Float2(0.8729032783f, -0.4878932944f), new Float2(0.8288345784f, 0.5594937369f), new Float2(0.08074567077f, 0.9967347374f), new Float2(0.9799148216f, -0.1994165048f), new Float2(-0.580730673f, -0.8140957471f), new Float2(-0.4700049791f, -0.8826637636f), new Float2(0.2409492979f, 0.9705377045f),
        new Float2(0.9437816757f, -0.3305694308f), new Float2(-0.8927998638f, -0.4504535528f), new Float2(-0.8069622304f, 0.5906030467f), new Float2(0.06258973166f, 0.9980393407f), new Float2(-0.9312597469f, 0.3643559849f), new Float2(0.5777449785f, 0.8162173362f), new Float2(-0.3360095855f, -0.941858566f), new Float2(0.697932075f, -0.7161639607f),
        new Float2(-0.002008157227f, -0.9999979837f), new Float2(-0.1827294312f, -0.9831632392f), new Float2(-0.6523911722f, 0.7578824173f), new Float2(-0.4302626911f, -0.9027037258f), new Float2(-0.9985126289f, -0.05452091251f), new Float2(-0.01028102172f, -0.9999471489f), new Float2(-0.4946071129f, 0.8691166802f), new Float2(-0.2999350194f, 0.9539596344f),
        new Float2(0.8165471961f, 0.5772786819f), new Float2(0.2697460475f, 0.962931498f), new Float2(-0.7306287391f, -0.6827749597f), new Float2(-0.7590952064f, -0.6509796216f), new Float2(-0.907053853f, 0.4210146171f), new Float2(-0.5104861064f, -0.8598860013f), new Float2(0.8613350597f, 0.5080373165f), new Float2(0.5007881595f, -0.8655698812f),
        new Float2(-0.654158152f, 0.7563577938f), new Float2(-0.8382755311f, -0.545246856f), new Float2(0.6940070834f, 0.7199681717f), new Float2(0.06950936031f, 0.9975812994f), new Float2(0.1702942185f, -0.9853932612f), new Float2(0.2695973274f, 0.9629731466f), new Float2(0.5519612192f, -0.8338697815f), new Float2(0.225657487f, -0.9742067022f),
        new Float2(0.4215262855f, -0.9068161835f), new Float2(0.4881873305f, -0.8727388672f), new Float2(-0.3683854996f, -0.9296731273f), new Float2(-0.9825390578f, 0.1860564427f), new Float2(0.81256471f, 0.5828709909f), new Float2(0.3196460933f, -0.9475370046f), new Float2(0.9570913859f, 0.2897862643f), new Float2(-0.6876655497f, -0.7260276109f),
        new Float2(-0.9988770922f, -0.047376731f), new Float2(-0.1250179027f, 0.992154486f), new Float2(-0.8280133617f, 0.560708367f), new Float2(0.9324863769f, -0.3612051451f), new Float2(0.6394653183f, 0.7688199442f), new Float2(-0.01623847064f, -0.9998681473f), new Float2(-0.9955014666f, -0.09474613458f), new Float2(-0.81453315f, 0.580117012f),
        new Float2(0.4037327978f, -0.9148769469f), new Float2(0.9944263371f, 0.1054336766f), new Float2(-0.1624711654f, 0.9867132919f), new Float2(-0.9949487814f, -0.100383875f), new Float2(-0.6995302564f, 0.7146029809f), new Float2(0.5263414922f, -0.85027327f), new Float2(-0.5395221479f, 0.841971408f), new Float2(0.6579370318f, 0.7530729462f),
        new Float2(0.01426758847f, -0.9998982128f), new Float2(-0.6734383991f, 0.7392433447f), new Float2(0.639412098f, -0.7688642071f), new Float2(0.9211571421f, 0.3891908523f), new Float2(-0.146637214f, -0.9891903394f), new Float2(-0.782318098f, 0.6228791163f), new Float2(-0.5039610839f, -0.8637263605f), new Float2(-0.7743120191f, -0.6328039957f),
        };

        private static readonly Float3[] CELL_3D = {
        new Float3(-0.7292736885f, -0.6618439697f, 0.1735581948f), new Float3(0.790292081f, -0.5480887466f, -0.2739291014f), new Float3(0.7217578935f, 0.6226212466f, -0.3023380997f), new Float3(0.565683137f, -0.8208298145f, -0.0790000257f), new Float3(0.760049034f, -0.5555979497f, -0.3370999617f), new Float3(0.3713945616f, 0.5011264475f, 0.7816254623f), new Float3(-0.1277062463f, -0.4254438999f, -0.8959289049f), new Float3(-0.2881560924f, -0.5815838982f, 0.7607405838f),
        new Float3(0.5849561111f, -0.662820239f, -0.4674352136f), new Float3(0.3307171178f, 0.0391653737f, 0.94291689f), new Float3(0.8712121778f, -0.4113374369f, -0.2679381538f), new Float3(0.580981015f, 0.7021915846f, 0.4115677815f), new Float3(0.503756873f, 0.6330056931f, -0.5878203852f), new Float3(0.4493712205f, 0.601390195f, 0.6606022552f), new Float3(-0.6878403724f, 0.09018890807f, -0.7202371714f), new Float3(-0.5958956522f, -0.6469350577f, 0.475797649f),
        new Float3(-0.5127052122f, 0.1946921978f, -0.8361987284f), new Float3(-0.9911507142f, -0.05410276466f, -0.1212153153f), new Float3(-0.2149721042f, 0.9720882117f, -0.09397607749f), new Float3(-0.7518650936f, -0.5428057603f, 0.3742469607f), new Float3(0.5237068895f, 0.8516377189f, -0.02107817834f), new Float3(0.6333504779f, 0.1926167129f, -0.7495104896f), new Float3(-0.06788241606f, 0.3998305789f, 0.9140719259f), new Float3(-0.5538628599f, -0.4729896695f, -0.6852128902f),
        new Float3(-0.7261455366f, -0.5911990757f, 0.3509933228f), new Float3(-0.9229274737f, -0.1782808786f, 0.3412049336f), new Float3(-0.6968815002f, 0.6511274338f, 0.3006480328f), new Float3(0.9608044783f, -0.2098363234f, -0.1811724921f), new Float3(0.06817146062f, -0.9743405129f, 0.2145069156f), new Float3(-0.3577285196f, -0.6697087264f, -0.6507845481f), new Float3(-0.1868621131f, 0.7648617052f, -0.6164974636f), new Float3(-0.6541697588f, 0.3967914832f, 0.6439087246f),
        new Float3(0.6993340405f, -0.6164538506f, 0.3618239211f), new Float3(-0.1546665739f, 0.6291283928f, 0.7617583057f), new Float3(-0.6841612949f, -0.2580482182f, -0.6821542638f), new Float3(0.5383980957f, 0.4258654885f, 0.7271630328f), new Float3(-0.5026987823f, -0.7939832935f, -0.3418836993f), new Float3(0.3202971715f, 0.2834415347f, 0.9039195862f), new Float3(0.8683227101f, -0.0003762656404f, -0.4959995258f), new Float3(0.791120031f, -0.08511045745f, 0.6057105799f),
        new Float3(-0.04011016052f, -0.4397248749f, 0.8972364289f), new Float3(0.9145119872f, 0.3579346169f, -0.1885487608f), new Float3(-0.9612039066f, -0.2756484276f, 0.01024666929f), new Float3(0.6510361721f, -0.2877799159f, -0.7023778346f), new Float3(-0.2041786351f, 0.7365237271f, 0.644859585f), new Float3(-0.7718263711f, 0.3790626912f, 0.5104855816f), new Float3(-0.3060082741f, -0.7692987727f, 0.5608371729f), new Float3(0.454007341f, -0.5024843065f, 0.7357899537f),
        new Float3(0.4816795475f, 0.6021208291f, -0.6367380315f), new Float3(0.6961980369f, -0.3222197429f, 0.641469197f), new Float3(-0.6532160499f, -0.6781148932f, 0.3368515753f), new Float3(0.5089301236f, -0.6154662304f, -0.6018234363f), new Float3(-0.1635919754f, -0.9133604627f, -0.372840892f), new Float3(0.52408019f, -0.8437664109f, 0.1157505864f), new Float3(0.5902587356f, 0.4983817807f, -0.6349883666f), new Float3(0.5863227872f, 0.494764745f, 0.6414307729f),
        new Float3(0.6779335087f, 0.2341345225f, 0.6968408593f), new Float3(0.7177054546f, -0.6858979348f, 0.120178631f), new Float3(-0.5328819713f, -0.5205125012f, 0.6671608058f), new Float3(-0.8654874251f, -0.0700727088f, -0.4960053754f), new Float3(-0.2861810166f, 0.7952089234f, 0.5345495242f), new Float3(-0.04849529634f, 0.9810836427f, -0.1874115585f), new Float3(-0.6358521667f, 0.6058348682f, 0.4781800233f), new Float3(0.6254794696f, -0.2861619734f, 0.7258696564f),
        new Float3(-0.2585259868f, 0.5061949264f, -0.8227581726f), new Float3(0.02136306781f, 0.5064016808f, -0.8620330371f), new Float3(0.200111773f, 0.8599263484f, 0.4695550591f), new Float3(0.4743561372f, 0.6014985084f, -0.6427953014f), new Float3(0.6622993731f, -0.5202474575f, -0.5391679918f), new Float3(0.08084972818f, -0.6532720452f, 0.7527940996f), new Float3(-0.6893687501f, 0.0592860349f, 0.7219805347f), new Float3(-0.1121887082f, -0.9673185067f, 0.2273952515f),
        new Float3(0.7344116094f, 0.5979668656f, -0.3210532909f), new Float3(0.5789393465f, -0.2488849713f, 0.7764570201f), new Float3(0.6988182827f, 0.3557169806f, -0.6205791146f), new Float3(-0.8636845529f, -0.2748771249f, -0.4224826141f), new Float3(-0.4247027957f, -0.4640880967f, 0.777335046f), new Float3(0.5257722489f, -0.8427017621f, 0.1158329937f), new Float3(0.9343830603f, 0.316302472f, -0.1639543925f), new Float3(-0.1016836419f, -0.8057303073f, -0.5834887393f),
        new Float3(-0.6529238969f, 0.50602126f, -0.5635892736f), new Float3(-0.2465286165f, -0.9668205684f, -0.06694497494f), new Float3(-0.9776897119f, -0.2099250524f, -0.007368825344f), new Float3(0.7736893337f, 0.5734244712f, 0.2694238123f), new Float3(-0.6095087895f, 0.4995678998f, 0.6155736747f), new Float3(0.5794535482f, 0.7434546771f, 0.3339292269f), new Float3(-0.8226211154f, 0.08142581855f, 0.5627293636f), new Float3(-0.510385483f, 0.4703667658f, 0.7199039967f),
        new Float3(-0.5764971849f, -0.07231656274f, -0.8138926898f), new Float3(0.7250628871f, 0.3949971505f, -0.5641463116f), new Float3(-0.1525424005f, 0.4860840828f, -0.8604958341f), new Float3(-0.5550976208f, -0.4957820792f, 0.667882296f), new Float3(-0.1883614327f, 0.9145869398f, 0.357841725f), new Float3(0.7625556724f, -0.5414408243f, -0.3540489801f), new Float3(-0.5870231946f, -0.3226498013f, -0.7424963803f), new Float3(0.3051124198f, 0.2262544068f, -0.9250488391f),
        new Float3(0.6379576059f, 0.577242424f, -0.5097070502f), new Float3(-0.5966775796f, 0.1454852398f, -0.7891830656f), new Float3(-0.658330573f, 0.6555487542f, -0.3699414651f), new Float3(0.7434892426f, 0.2351084581f, 0.6260573129f), new Float3(0.5562114096f, 0.8264360377f, -0.0873632843f), new Float3(-0.3028940016f, -0.8251527185f, 0.4768419182f), new Float3(0.1129343818f, -0.985888439f, -0.1235710781f), new Float3(0.5937652891f, -0.5896813806f, 0.5474656618f),
        new Float3(0.6757964092f, -0.5835758614f, -0.4502648413f), new Float3(0.7242302609f, -0.1152719764f, 0.6798550586f), new Float3(-0.9511914166f, 0.0753623979f, -0.2992580792f), new Float3(0.2539470961f, -0.1886339355f, 0.9486454084f), new Float3(0.571433621f, -0.1679450851f, -0.8032795685f), new Float3(-0.06778234979f, 0.3978269256f, 0.9149531629f), new Float3(0.6074972649f, 0.733060024f, -0.3058922593f), new Float3(-0.5435478392f, 0.1675822484f, 0.8224791405f),
        new Float3(-0.5876678086f, -0.3380045064f, -0.7351186982f), new Float3(-0.7967562402f, 0.04097822706f, -0.6029098428f), new Float3(-0.1996350917f, 0.8706294745f, 0.4496111079f), new Float3(-0.02787660336f, -0.9106232682f, -0.4122962022f), new Float3(-0.7797625996f, -0.6257634692f, 0.01975775581f), new Float3(-0.5211232846f, 0.7401644346f, -0.4249554471f), new Float3(0.8575424857f, 0.4053272873f, -0.3167501783f), new Float3(0.1045223322f, 0.8390195772f, -0.5339674439f),
        new Float3(0.3501822831f, 0.9242524096f, -0.1520850155f), new Float3(0.1987849858f, 0.07647613266f, 0.9770547224f), new Float3(0.7845996363f, 0.6066256811f, -0.1280964233f), new Float3(0.09006737436f, -0.9750989929f, -0.2026569073f), new Float3(-0.8274343547f, -0.542299559f, 0.1458203587f), new Float3(-0.3485797732f, -0.415802277f, 0.840000362f), new Float3(-0.2471778936f, -0.7304819962f, -0.6366310879f), new Float3(-0.3700154943f, 0.8577948156f, 0.3567584454f),
        new Float3(0.5913394901f, -0.548311967f, -0.5913303597f), new Float3(0.1204873514f, -0.7626472379f, -0.6354935001f), new Float3(0.616959265f, 0.03079647928f, 0.7863922953f), new Float3(0.1258156836f, -0.6640829889f, -0.7369967419f), new Float3(-0.6477565124f, -0.1740147258f, -0.7417077429f), new Float3(0.6217889313f, -0.7804430448f, -0.06547655076f), new Float3(0.6589943422f, -0.6096987708f, 0.4404473475f), new Float3(-0.2689837504f, -0.6732403169f, -0.6887635427f),
        new Float3(-0.3849775103f, 0.5676542638f, 0.7277093879f), new Float3(0.5754444408f, 0.8110471154f, -0.1051963504f), new Float3(0.9141593684f, 0.3832947817f, 0.131900567f), new Float3(-0.107925319f, 0.9245493968f, 0.3654593525f), new Float3(0.377977089f, 0.3043148782f, 0.8743716458f), new Float3(-0.2142885215f, -0.8259286236f, 0.5214617324f), new Float3(0.5802544474f, 0.4148098596f, -0.7008834116f), new Float3(-0.1982660881f, 0.8567161266f, -0.4761596756f),
        new Float3(-0.03381553704f, 0.3773180787f, -0.9254661404f), new Float3(-0.6867922841f, -0.6656597827f, 0.2919133642f), new Float3(0.7731742607f, -0.2875793547f, -0.5652430251f), new Float3(-0.09655941928f, 0.9193708367f, -0.3813575004f), new Float3(0.2715702457f, -0.9577909544f, -0.09426605581f), new Float3(0.2451015704f, -0.6917998565f, -0.6792188003f), new Float3(0.977700782f, -0.1753855374f, 0.1155036542f), new Float3(-0.5224739938f, 0.8521606816f, 0.02903615945f),
        new Float3(-0.7734880599f, -0.5261292347f, 0.3534179531f), new Float3(-0.7134492443f, -0.269547243f, 0.6467878011f), new Float3(0.1644037271f, 0.5105846203f, -0.8439637196f), new Float3(0.6494635788f, 0.05585611296f, 0.7583384168f), new Float3(-0.4711970882f, 0.5017280509f, -0.7254255765f), new Float3(-0.6335764307f, -0.2381686273f, -0.7361091029f), new Float3(-0.9021533097f, -0.270947803f, -0.3357181763f), new Float3(-0.3793711033f, 0.872258117f, 0.3086152025f),
        new Float3(-0.6855598966f, -0.3250143309f, 0.6514394162f), new Float3(0.2900942212f, -0.7799057743f, -0.5546100667f), new Float3(-0.2098319339f, 0.85037073f, 0.4825351604f), new Float3(-0.4592603758f, 0.6598504336f, -0.5947077538f), new Float3(0.8715945488f, 0.09616365406f, -0.4807031248f), new Float3(-0.6776666319f, 0.7118504878f, -0.1844907016f), new Float3(0.7044377633f, 0.312427597f, 0.637304036f), new Float3(-0.7052318886f, -0.2401093292f, -0.6670798253f),
        new Float3(0.081921007f, -0.7207336136f, -0.6883545647f), new Float3(-0.6993680906f, -0.5875763221f, -0.4069869034f), new Float3(-0.1281454481f, 0.6419895885f, 0.7559286424f), new Float3(-0.6337388239f, -0.6785471501f, -0.3714146849f), new Float3(0.5565051903f, -0.2168887573f, -0.8020356851f), new Float3(-0.5791554484f, 0.7244372011f, -0.3738578718f), new Float3(0.1175779076f, -0.7096451073f, 0.6946792478f), new Float3(-0.6134619607f, 0.1323631078f, 0.7785527795f),
        new Float3(0.6984635305f, -0.02980516237f, -0.715024719f), new Float3(0.8318082963f, -0.3930171956f, 0.3919597455f), new Float3(0.1469576422f, 0.05541651717f, -0.9875892167f), new Float3(0.708868575f, -0.2690503865f, 0.6520101478f), new Float3(0.2726053183f, 0.67369766f, -0.68688995f), new Float3(-0.6591295371f, 0.3035458599f, -0.6880466294f), new Float3(0.4815131379f, -0.7528270071f, 0.4487723203f), new Float3(0.9430009463f, 0.1675647412f, -0.2875261255f),
        new Float3(0.434802957f, 0.7695304522f, -0.4677277752f), new Float3(0.3931996188f, 0.594473625f, 0.7014236729f), new Float3(0.7254336655f, -0.603925654f, 0.3301814672f), new Float3(0.7590235227f, -0.6506083235f, 0.02433313207f), new Float3(-0.8552768592f, -0.3430042733f, 0.3883935666f), new Float3(-0.6139746835f, 0.6981725247f, 0.3682257648f), new Float3(-0.7465905486f, -0.5752009504f, 0.3342849376f), new Float3(0.5730065677f, 0.810555537f, -0.1210916791f),
        new Float3(-0.9225877367f, -0.3475211012f, -0.167514036f), new Float3(-0.7105816789f, -0.4719692027f, -0.5218416899f), new Float3(-0.08564609717f, 0.3583001386f, 0.929669703f), new Float3(-0.8279697606f, -0.2043157126f, 0.5222271202f), new Float3(0.427944023f, 0.278165994f, 0.8599346446f), new Float3(0.5399079671f, -0.7857120652f, -0.3019204161f), new Float3(0.5678404253f, -0.5495413974f, -0.6128307303f), new Float3(-0.9896071041f, 0.1365639107f, -0.04503418428f),
        new Float3(-0.6154342638f, -0.6440875597f, 0.4543037336f), new Float3(0.1074204368f, -0.7946340692f, 0.5975094525f), new Float3(-0.3595449969f, -0.8885529948f, 0.28495784f), new Float3(-0.2180405296f, 0.1529888965f, 0.9638738118f), new Float3(-0.7277432317f, -0.6164050508f, -0.3007234646f), new Float3(0.7249729114f, -0.00669719484f, 0.6887448187f), new Float3(-0.5553659455f, -0.5336586252f, 0.6377908264f), new Float3(0.5137558015f, 0.7976208196f, -0.3160000073f),
        new Float3(-0.3794024848f, 0.9245608561f, -0.03522751494f), new Float3(0.8229248658f, 0.2745365933f, -0.4974176556f), new Float3(-0.5404114394f, 0.6091141441f, 0.5804613989f), new Float3(0.8036581901f, -0.2703029469f, 0.5301601931f), new Float3(0.6044318879f, 0.6832968393f, 0.4095943388f), new Float3(0.06389988817f, 0.9658208605f, -0.2512108074f), new Float3(0.1087113286f, 0.7402471173f, -0.6634877936f), new Float3(-0.713427712f, -0.6926784018f, 0.1059128479f),
        new Float3(0.6458897819f, -0.5724548511f, -0.5050958653f), new Float3(-0.6553931414f, 0.7381471625f, 0.159995615f), new Float3(0.3910961323f, 0.9188871375f, -0.05186755998f), new Float3(-0.4879022471f, -0.5904376907f, 0.6429111375f), new Float3(0.6014790094f, 0.7707441366f, -0.2101820095f), new Float3(-0.5677173047f, 0.7511360995f, 0.3368851762f), new Float3(0.7858573506f, 0.226674665f, 0.5753666838f), new Float3(-0.4520345543f, -0.604222686f, -0.6561857263f),
        new Float3(0.002272116345f, 0.4132844051f, -0.9105991643f), new Float3(-0.5815751419f, -0.5162925989f, 0.6286591339f), new Float3(-0.03703704785f, 0.8273785755f, 0.5604221175f), new Float3(-0.5119692504f, 0.7953543429f, -0.3244980058f), new Float3(-0.2682417366f, -0.9572290247f, -0.1084387619f), new Float3(-0.2322482736f, -0.9679131102f, -0.09594243324f), new Float3(0.3554328906f, -0.8881505545f, 0.2913006227f), new Float3(0.7346520519f, -0.4371373164f, 0.5188422971f),
        new Float3(0.9985120116f, 0.04659011161f, -0.02833944577f), new Float3(-0.3727687496f, -0.9082481361f, 0.1900757285f), new Float3(0.91737377f, -0.3483642108f, 0.1925298489f), new Float3(0.2714911074f, 0.4147529736f, -0.8684886582f), new Float3(0.5131763485f, -0.7116334161f, 0.4798207128f), new Float3(-0.8737353606f, 0.18886992f, -0.4482350644f), new Float3(0.8460043821f, -0.3725217914f, 0.3814499973f), new Float3(0.8978727456f, -0.1780209141f, -0.4026575304f),
        new Float3(0.2178065647f, -0.9698322841f, -0.1094789531f), new Float3(-0.1518031304f, -0.7788918132f, -0.6085091231f), new Float3(-0.2600384876f, -0.4755398075f, -0.8403819825f), new Float3(0.572313509f, -0.7474340931f, -0.3373418503f), new Float3(-0.7174141009f, 0.1699017182f, -0.6756111411f), new Float3(-0.684180784f, 0.02145707593f, -0.7289967412f), new Float3(-0.2007447902f, 0.06555605789f, -0.9774476623f), new Float3(-0.1148803697f, -0.8044887315f, 0.5827524187f),
        new Float3(-0.7870349638f, 0.03447489231f, 0.6159443543f), new Float3(-0.2015596421f, 0.6859872284f, 0.6991389226f), new Float3(-0.08581082512f, -0.10920836f, -0.9903080513f), new Float3(0.5532693395f, 0.7325250401f, -0.396610771f), new Float3(-0.1842489331f, -0.9777375055f, -0.1004076743f), new Float3(0.0775473789f, -0.9111505856f, 0.4047110257f), new Float3(0.1399838409f, 0.7601631212f, -0.6344734459f), new Float3(0.4484419361f, -0.845289248f, 0.2904925424f),
        };
        #endregion

        //[MethodImpl(FN_INLINE)]
        //private static int FastFloor(double f) => (f >= 0 ? (int)f : (int)f - 1);

        [MethodImpl(FN_INLINE)]
        private static int FastRound(double f) => (f >= 0) ? (int)(f + 0.5) : (int)(f - 0.5);

        [MethodImpl(FN_INLINE)]
        private static double Lerp(double a, double b, double t) => a + t * (b - a);

        [MethodImpl(FN_INLINE)]
        private static double InterpHermiteFunc(double t) => t * t * (3 - 2 * t);

        [MethodImpl(FN_INLINE)]
        private static double InterpQuinticFunc(double t) => t * t * t * (t * (t * 6 - 15) + 10);

        [MethodImpl(FN_INLINE)]
        private static double CubicLerp(double a, double b, double c, double d, double t) {
            double p = (d - c) - (a - b);
            return t * t * t * p + t * t * ((a - b) - p) + t * (c - a) + b;
        }

        private void CalculateFractalBounding() {
            double amp = gain;
            double ampFractal = 1;
            for (int i = 1; i < octaves; i++) {
                ampFractal += amp;
                amp *= gain;
            }
            fractalBounding = 1 / ampFractal;
        }

        [MethodImpl(FN_INLINE)]
        private static double ValCoord2D(int seed, int x, int y) => (int)HashAll(x, y, seed) * 4.6566128730773926E-10;

        [MethodImpl(FN_INLINE)]
        private static double ValCoord3D(int seed, int x, int y, int z) => (int)HashAll(x, y, z, seed) * 4.6566128730773926E-10;

        [MethodImpl(FN_INLINE)]
        private static double ValCoord4D(int seed, int x, int y, int z, int w) => (int)HashAll(x, y, z, w, seed) * 4.6566128730773926E-10;

        [MethodImpl(FN_INLINE)]
        private static double GradCoord2D(int seed, int x, int y, double xd, double yd) {
            uint hash = Hash256(x, y, seed) << 1;
            return xd * GRAD_2D[hash] + yd * GRAD_2D[hash+1];
        }

        [MethodImpl(FN_INLINE)]
        private static double GradCoord3D(int seed, int x, int y, int z, double xd, double yd, double zd) {
            Float3 g = GRAD_3D[Hash32(x, y, z, seed)];
            return xd * g.x + yd * g.y + zd * g.z;
        }

        [MethodImpl(FN_INLINE)]
        private static double GradCoord4D(int seed, int x, int y, int z, int w, double xd, double yd, double zd, double wd) {
            uint hash = Hash64(x, y, z, w, seed) << 2;
            return xd * GRAD_2D[hash] + yd * GRAD_2D[hash + 1] + zd * GRAD_2D[hash + 2] + wd * GRAD_4D[hash + 3];
            //uint hash = Hash32(x, y, z, w, seed);
            //double a, b, c;            
            //switch (hash >> 3) {          // DEPENDING ON HIGH ORDER 2 BITS:
            //    case 1: a = wd; b = xd; c = yd; break;     // W,X,Y
            //    case 2: a = zd; b = wd; c = xd; break;     // Z,W,X
            //    case 3: a = yd; b = zd; c = wd; break;     // Y,Z,W
            //    default: a = xd; b = yd; c = zd; break;    // X,Y,Z
            //}
            //return ((hash & 4) == 0 ? -a : a) + ((hash & 2) == 0 ? -b : b) + ((hash & 1) == 0 ? -c : c);
        }

        public double GetNoise(double x, double y, double z) {
            x *= frequency;
            y *= frequency;
            z *= frequency;

            switch (noiseType) {
                case NoiseType.Value:
                    return SingleValue(seed, x, y, z);
                case NoiseType.ValueFractal:
                    switch (fractalType) {
                        case FractalType.FBM:
                            return SingleValueFractalFBM(x, y, z);
                        case FractalType.Billow:
                            return SingleValueFractalBillow(x, y, z);
                        case FractalType.Ridged:
                            return SingleValueFractalRidgedMulti(x, y, z);
                        default:
                            return 0;
                    }
                case NoiseType.Perlin:
                    return SinglePerlin(seed, x, y, z);
                case NoiseType.PerlinFractal:
                    switch (fractalType) {
                        case FractalType.FBM:
                            return SinglePerlinFractalFBM(x, y, z);
                        case FractalType.Billow:
                            return SinglePerlinFractalBillow(x, y, z);
                        case FractalType.Ridged:
                            return SinglePerlinFractalRidgedMulti(x, y, z);
                        default:
                            return 0;
                    }
                case NoiseType.Simplex:
                    return SingleSimplex(seed, x, y, z);
                case NoiseType.SimplexFractal:
                    switch (fractalType) {
                        case FractalType.FBM:
                            return SingleSimplexFractalFBM(x, y, z);
                        case FractalType.Billow:
                            return SingleSimplexFractalBillow(x, y, z);
                        case FractalType.Ridged:
                            return SingleSimplexFractalRidgedMulti(x, y, z);
                        default:
                            return 0;
                    }
                case NoiseType.Cellular:
                    switch (cellularReturnType) {
                        case CellularReturnType.CellValue:
                        case CellularReturnType.NoiseLookup:
                        case CellularReturnType.Distance:
                            return SingleCellular(x, y, z);
                        default:
                            return SingleCellular2Edge(x, y, z);
                    }
                case NoiseType.WhiteNoise:
                    return GetWhiteNoise(x, y, z);
                case NoiseType.Cubic:
                    return SingleCubic(seed, x, y, z);
                case NoiseType.CubicFractal:
                    switch (fractalType) {
                        case FractalType.FBM:
                            return SingleCubicFractalFBM(x, y, z);
                        case FractalType.Billow:
                            return SingleCubicFractalBillow(x, y, z);
                        case FractalType.Ridged:
                            return SingleCubicFractalRidgedMulti(x, y, z);
                        default:
                            return 0;
                    }
                default:
                    return 0;
            }
        }

        public double GetNoise(double x, double y) {
            x *= frequency;
            y *= frequency;

            switch (noiseType) {
                case NoiseType.Value:
                    return SingleValue(seed, x, y);
                case NoiseType.ValueFractal:
                    switch (fractalType) {
                        case FractalType.FBM:
                            return SingleValueFractalFBM(x, y);
                        case FractalType.Billow:
                            return SingleValueFractalBillow(x, y);
                        case FractalType.Ridged:
                            return SingleValueFractalRidgedMulti(x, y);
                        default:
                            return 0;
                    }
                case NoiseType.Perlin:
                    return SinglePerlin(seed, x, y);
                case NoiseType.PerlinFractal:
                    switch (fractalType) {
                        case FractalType.FBM:
                            return SinglePerlinFractalFBM(x, y);
                        case FractalType.Billow:
                            return SinglePerlinFractalBillow(x, y);
                        case FractalType.Ridged:
                            return SinglePerlinFractalRidgedMulti(x, y);
                        default:
                            return 0;
                    }
                case NoiseType.Simplex:
                    return SingleSimplex(seed, x, y);
                case NoiseType.SimplexFractal:
                    switch (fractalType) {
                        case FractalType.FBM:
                            return SingleSimplexFractalFBM(x, y);
                        case FractalType.Billow:
                            return SingleSimplexFractalBillow(x, y);
                        case FractalType.Ridged:
                            return SingleSimplexFractalRidgedMulti(x, y);
                        default:
                            return 0;
                    }
                case NoiseType.Cellular:
                    switch (cellularReturnType) {
                        case CellularReturnType.CellValue:
                        case CellularReturnType.NoiseLookup:
                        case CellularReturnType.Distance:
                            return SingleCellular(x, y);
                        default:
                            return SingleCellular2Edge(x, y);
                    }
                case NoiseType.WhiteNoise:
                    return GetWhiteNoise(x, y);
                case NoiseType.Cubic:
                    return SingleCubic(seed, x, y);
                case NoiseType.CubicFractal:
                    switch (fractalType) {
                        case FractalType.FBM:
                            return SingleCubicFractalFBM(x, y);
                        case FractalType.Billow:
                            return SingleCubicFractalBillow(x, y);
                        case FractalType.Ridged:
                            return SingleCubicFractalRidgedMulti(x, y);
                        default:
                            return 0;
                    }
                default:
                    return 0;
            }
        }

        // White Noise
        [MethodImpl(FN_INLINE)]
        private static int FloatCast2Int(double f) {
            long i = BitConverter.DoubleToInt64Bits(f);

            return (int)(i ^ (i >> 32));
        }

        public double GetWhiteNoise(double x, double y, double z, double w) {
            int xi = FloatCast2Int(x);
            int yi = FloatCast2Int(y);
            int zi = FloatCast2Int(z);
            int wi = FloatCast2Int(w);

            return ValCoord4D(seed, xi, yi, zi, wi);
        }

        public double GetWhiteNoise(double x, double y, double z) {
            int xi = FloatCast2Int(x);
            int yi = FloatCast2Int(y);
            int zi = FloatCast2Int(z);

            return ValCoord3D(seed, xi, yi, zi);
        }

        public double GetWhiteNoise(double x, double y) {
            int xi = FloatCast2Int(x);
            int yi = FloatCast2Int(y);

            return ValCoord2D(seed, xi, yi);
        }

        public double GetWhiteNoiseInt(int x, int y, int z, int w) => ValCoord4D(seed, x, y, z, w);

        public double GetWhiteNoiseInt(int x, int y, int z) => ValCoord3D(seed, x, y, z);

        public double GetWhiteNoiseInt(int x, int y) => ValCoord2D(seed, x, y);

        // Value Noise
        public double GetValueFractal(double x, double y, double z) {
            x *= frequency;
            y *= frequency;
            z *= frequency;

            switch (fractalType) {
                case FractalType.FBM:
                    return SingleValueFractalFBM(x, y, z);
                case FractalType.Billow:
                    return SingleValueFractalBillow(x, y, z);
                case FractalType.Ridged:
                    return SingleValueFractalRidgedMulti(x, y, z);
                default:
                    return 0;
            }
        }

        private double SingleValueFractalFBM(double x, double y, double z) {
            int seed = this.seed;
            double sum = SingleValue(seed, x, y, z);
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum += SingleValue(++seed, x, y, z) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleValueFractalBillow(double x, double y, double z) {
            int seed = this.seed;
            double sum = Math.Abs(SingleValue(seed, x, y, z)) * 2 - 1;
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum += (Math.Abs(SingleValue(++seed, x, y, z)) * 2 - 1) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleValueFractalRidgedMulti(double x, double y, double z) {
            int seed = this.seed;
            double sum = 1 - Math.Abs(SingleValue(seed, x, y, z));
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum -= (1 - Math.Abs(SingleValue(++seed, x, y, z))) * amp;
            }

            return sum;
        }

        public double GetValue(double x, double y, double z) => SingleValue(seed, x * frequency, y * frequency, z * frequency);

        private double SingleValue(int seed, double x, double y, double z) {
            int x0 = FastFloor(x);
            int y0 = FastFloor(y);
            int z0 = FastFloor(z);
            int x1 = x0 + 1;
            int y1 = y0 + 1;
            int z1 = z0 + 1;

            double xs, ys, zs;
            switch (interp) {
                default:
                case Interp.Linear:
                    xs = x - x0;
                    ys = y - y0;
                    zs = z - z0;
                    break;
                case Interp.Hermite:
                    xs = InterpHermiteFunc(x - x0);
                    ys = InterpHermiteFunc(y - y0);
                    zs = InterpHermiteFunc(z - z0);
                    break;
                case Interp.Quintic:
                    xs = InterpQuinticFunc(x - x0);
                    ys = InterpQuinticFunc(y - y0);
                    zs = InterpQuinticFunc(z - z0);
                    break;
            }

            double xf00 = Lerp(ValCoord3D(seed, x0, y0, z0), ValCoord3D(seed, x1, y0, z0), xs);
            double xf10 = Lerp(ValCoord3D(seed, x0, y1, z0), ValCoord3D(seed, x1, y1, z0), xs);
            double xf01 = Lerp(ValCoord3D(seed, x0, y0, z1), ValCoord3D(seed, x1, y0, z1), xs);
            double xf11 = Lerp(ValCoord3D(seed, x0, y1, z1), ValCoord3D(seed, x1, y1, z1), xs);

            double yf0 = Lerp(xf00, xf10, ys);
            double yf1 = Lerp(xf01, xf11, ys);

            return Lerp(yf0, yf1, zs);
        }

        public double GetValueFractal(double x, double y) {
            x *= frequency;
            y *= frequency;

            switch (fractalType) {
                case FractalType.FBM:
                    return SingleValueFractalFBM(x, y);
                case FractalType.Billow:
                    return SingleValueFractalBillow(x, y);
                case FractalType.Ridged:
                    return SingleValueFractalRidgedMulti(x, y);
                default:
                    return 0;
            }
        }

        private double SingleValueFractalFBM(double x, double y) {
            int seed = this.seed;
            double sum = SingleValue(seed, x, y);
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum += SingleValue(++seed, x, y) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleValueFractalBillow(double x, double y) {
            int seed = this.seed;
            double sum = Math.Abs(SingleValue(seed, x, y)) * 2 - 1;
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                amp *= gain;
                sum += (Math.Abs(SingleValue(++seed, x, y)) * 2 - 1) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleValueFractalRidgedMulti(double x, double y) {
            int seed = this.seed;
            double sum = 1 - Math.Abs(SingleValue(seed, x, y));
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum -= (1 - Math.Abs(SingleValue(++seed, x, y))) * amp;
            }

            return sum;
        }

        public double GetValue(double x, double y) => SingleValue(seed, x * frequency, y * frequency);

        private double SingleValue(int seed, double x, double y) {
            int x0 = FastFloor(x);
            int y0 = FastFloor(y);
            int x1 = x0 + 1;
            int y1 = y0 + 1;

            double xs, ys;
            switch (interp) {
                default:
                case Interp.Linear:
                    xs = x - x0;
                    ys = y - y0;
                    break;
                case Interp.Hermite:
                    xs = InterpHermiteFunc(x - x0);
                    ys = InterpHermiteFunc(y - y0);
                    break;
                case Interp.Quintic:
                    xs = InterpQuinticFunc(x - x0);
                    ys = InterpQuinticFunc(y - y0);
                    break;
            }

            double xf0 = Lerp(ValCoord2D(seed, x0, y0), ValCoord2D(seed, x1, y0), xs);
            double xf1 = Lerp(ValCoord2D(seed, x0, y1), ValCoord2D(seed, x1, y1), xs);

            return Lerp(xf0, xf1, ys);
        }

        // Gradient Noise
        public double GetPerlinFractal(double x, double y, double z) {
            x *= frequency;
            y *= frequency;
            z *= frequency;

            switch (fractalType) {
                case FractalType.FBM:
                    return SinglePerlinFractalFBM(x, y, z);
                case FractalType.Billow:
                    return SinglePerlinFractalBillow(x, y, z);
                case FractalType.Ridged:
                    return SinglePerlinFractalRidgedMulti(x, y, z);
                default:
                    return 0;
            }
        }

        private double SinglePerlinFractalFBM(double x, double y, double z) {
            int seed = this.seed;
            double sum = SinglePerlin(seed, x, y, z);
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum += SinglePerlin(++seed, x, y, z) * amp;
            }

            return sum * fractalBounding;
        }

        private double SinglePerlinFractalBillow(double x, double y, double z) {
            int seed = this.seed;
            double sum = Math.Abs(SinglePerlin(seed, x, y, z)) * 2 - 1;
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum += (Math.Abs(SinglePerlin(++seed, x, y, z)) * 2 - 1) * amp;
            }

            return sum * fractalBounding;
        }

        private double SinglePerlinFractalRidgedMulti(double x, double y, double z) {
            int seed = this.seed;
            double sum = 1 - Math.Abs(SinglePerlin(seed, x, y, z));
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum -= (1 - Math.Abs(SinglePerlin(++seed, x, y, z))) * amp;
            }

            return sum;
        }

        public double GetPerlin(double x, double y, double z) => SinglePerlin(seed, x * frequency, y * frequency, z * frequency);

        private double SinglePerlin(int seed, double x, double y, double z) {
            int x0 = FastFloor(x);
            int y0 = FastFloor(y);
            int z0 = FastFloor(z);
            int x1 = x0 + 1;
            int y1 = y0 + 1;
            int z1 = z0 + 1;

            double xs, ys, zs;
            switch (interp) {
                default:
                case Interp.Linear:
                    xs = x - x0;
                    ys = y - y0;
                    zs = z - z0;
                    break;
                case Interp.Hermite:
                    xs = InterpHermiteFunc(x - x0);
                    ys = InterpHermiteFunc(y - y0);
                    zs = InterpHermiteFunc(z - z0);
                    break;
                case Interp.Quintic:
                    xs = InterpQuinticFunc(x - x0);
                    ys = InterpQuinticFunc(y - y0);
                    zs = InterpQuinticFunc(z - z0);
                    break;
            }

            double xd0 = x - x0;
            double yd0 = y - y0;
            double zd0 = z - z0;
            double xd1 = xd0 - 1;
            double yd1 = yd0 - 1;
            double zd1 = zd0 - 1;

            double xf00 = Lerp(GradCoord3D(seed, x0, y0, z0, xd0, yd0, zd0), GradCoord3D(seed, x1, y0, z0, xd1, yd0, zd0), xs);
            double xf10 = Lerp(GradCoord3D(seed, x0, y1, z0, xd0, yd1, zd0), GradCoord3D(seed, x1, y1, z0, xd1, yd1, zd0), xs);
            double xf01 = Lerp(GradCoord3D(seed, x0, y0, z1, xd0, yd0, zd1), GradCoord3D(seed, x1, y0, z1, xd1, yd0, zd1), xs);
            double xf11 = Lerp(GradCoord3D(seed, x0, y1, z1, xd0, yd1, zd1), GradCoord3D(seed, x1, y1, z1, xd1, yd1, zd1), xs);

            double yf0 = Lerp(xf00, xf10, ys);
            double yf1 = Lerp(xf01, xf11, ys);

            return Lerp(yf0, yf1, zs);
        }

        public double GetPerlinFractal(double x, double y) {
            x *= frequency;
            y *= frequency;

            switch (fractalType) {
                case FractalType.FBM:
                    return SinglePerlinFractalFBM(x, y);
                case FractalType.Billow:
                    return SinglePerlinFractalBillow(x, y);
                case FractalType.Ridged:
                    return SinglePerlinFractalRidgedMulti(x, y);
                default:
                    return 0;
            }
        }

        private double SinglePerlinFractalFBM(double x, double y) {
            int seed = this.seed;
            double sum = SinglePerlin(seed, x, y);
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum += SinglePerlin(++seed, x, y) * amp;
            }

            return sum * fractalBounding;
        }

        private double SinglePerlinFractalBillow(double x, double y) {
            int seed = this.seed;
            double sum = Math.Abs(SinglePerlin(seed, x, y)) * 2 - 1;
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum += (Math.Abs(SinglePerlin(++seed, x, y)) * 2 - 1) * amp;
            }

            return sum * fractalBounding;
        }

        private double SinglePerlinFractalRidgedMulti(double x, double y) {
            int seed = this.seed;
            double sum = 1 - Math.Abs(SinglePerlin(seed, x, y));
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum -= (1 - Math.Abs(SinglePerlin(++seed, x, y))) * amp;
            }

            return sum;
        }

        public double GetPerlin(double x, double y) => SinglePerlin(seed, x * frequency, y * frequency);

        private double SinglePerlin(int seed, double x, double y) {
            int x0 = FastFloor(x);
            int y0 = FastFloor(y);
            int x1 = x0 + 1;
            int y1 = y0 + 1;

            double xs, ys;
            switch (interp) {
                default:
                case Interp.Linear:
                    xs = x - x0;
                    ys = y - y0;
                    break;
                case Interp.Hermite:
                    xs = InterpHermiteFunc(x - x0);
                    ys = InterpHermiteFunc(y - y0);
                    break;
                case Interp.Quintic:
                    xs = InterpQuinticFunc(x - x0);
                    ys = InterpQuinticFunc(y - y0);
                    break;
            }

            double xd0 = x - x0;
            double yd0 = y - y0;
            double xd1 = xd0 - 1;
            double yd1 = yd0 - 1;

            double xf0 = Lerp(GradCoord2D(seed, x0, y0, xd0, yd0), GradCoord2D(seed, x1, y0, xd1, yd0), xs);
            double xf1 = Lerp(GradCoord2D(seed, x0, y1, xd0, yd1), GradCoord2D(seed, x1, y1, xd1, yd1), xs);

            return Lerp(xf0, xf1, ys);
        }

        // Simplex Noise
        public double GetSimplexFractal(double x, double y, double z) {
            x *= frequency;
            y *= frequency;
            z *= frequency;

            switch (fractalType) {
                case FractalType.FBM:
                    return SingleSimplexFractalFBM(x, y, z);
                case FractalType.Billow:
                    return SingleSimplexFractalBillow(x, y, z);
                case FractalType.Ridged:
                    return SingleSimplexFractalRidgedMulti(x, y, z);
                default:
                    return 0;
            }
        }

        private double SingleSimplexFractalFBM(double x, double y, double z) {
            int seed = this.seed;
            double sum = SingleSimplex(seed, x, y, z);
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum += SingleSimplex(++seed, x, y, z) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleSimplexFractalBillow(double x, double y, double z) {
            int seed = this.seed;
            double sum = Math.Abs(SingleSimplex(seed, x, y, z)) * 2 - 1;
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum += (Math.Abs(SingleSimplex(++seed, x, y, z)) * 2 - 1) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleSimplexFractalRidgedMulti(double x, double y, double z) {
            int seed = this.seed;
            double sum = 1 - Math.Abs(SingleSimplex(seed, x, y, z));
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum -= (1 - Math.Abs(SingleSimplex(++seed, x, y, z))) * amp;
            }

            return sum;
        }

        public double GetSimplex(double x, double y, double z) => SingleSimplex(seed, x * frequency, y * frequency, z * frequency);

        private const double F3 = 1.0 / 3.0;
        private const double G3 = 1.0 / 6.0;
        private const double G33 = G3 * 3 - 1;

        private static double SingleSimplex(int seed, double x, double y, double z) {
            double t = (x + y + z) * F3;
            int i = FastFloor(x + t);
            int j = FastFloor(y + t);
            int k = FastFloor(z + t);

            t = (i + j + k) * G3;
            double x0 = x - (i - t);
            double y0 = y - (j - t);
            double z0 = z - (k - t);

            int i1, j1, k1;
            int i2, j2, k2;

            if (x0 >= y0) {
                if (y0 >= z0) {
                    i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
                } else if (x0 >= z0) {
                    i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;
                } else // x0 < z0
                  {
                    i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;
                }
            } else // x0 < y0
              {
                if (y0 < z0) {
                    i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;
                } else if (x0 < z0) {
                    i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;
                } else // x0 >= z0
                  {
                    i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
                }
            }

            double x1 = x0 - i1 + G3;
            double y1 = y0 - j1 + G3;
            double z1 = z0 - k1 + G3;
            double x2 = x0 - i2 + F3;
            double y2 = y0 - j2 + F3;
            double z2 = z0 - k2 + F3;
            double x3 = x0 + G33;
            double y3 = y0 + G33;
            double z3 = z0 + G33;

            double n0, n1, n2, n3;

            t = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
            if (t <= 0) n0 = 0;
            else {
                t *= t;
                n0 = t * t * GradCoord3D(seed, i, j, k, x0, y0, z0);
            }

            t = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
            if (t <= 0) n1 = 0;
            else {
                t *= t;
                n1 = t * t * GradCoord3D(seed, i + i1, j + j1, k + k1, x1, y1, z1);
            }

            t = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
            if (t <= 0) n2 = 0;
            else {
                t *= t;
                n2 = t * t * GradCoord3D(seed, i + i2, j + j2, k + k2, x2, y2, z2);
            }

            t = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
            if (t <= 0) n3 = 0;
            else {
                t *= t;
                n3 = t * t * GradCoord3D(seed, i + 1, j + 1, k + 1, x3, y3, z3);
            }

            return 32 * (n0 + n1 + n2 + n3);
        }

        public double GetSimplexFractal(double x, double y) {
            x *= frequency;
            y *= frequency;

            switch (fractalType) {
                case FractalType.FBM:
                    return SingleSimplexFractalFBM(x, y);
                case FractalType.Billow:
                    return SingleSimplexFractalBillow(x, y);
                case FractalType.Ridged:
                    return SingleSimplexFractalRidgedMulti(x, y);
                default:
                    return 0;
            }
        }

        private double SingleSimplexFractalFBM(double x, double y) {
            int seed = this.seed;
            double sum = SingleSimplex(seed, x, y);
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum += SingleSimplex(++seed, x, y) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleSimplexFractalBillow(double x, double y) {
            int seed = this.seed;
            double sum = Math.Abs(SingleSimplex(seed, x, y)) * 2 - 1;
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum += (Math.Abs(SingleSimplex(++seed, x, y)) * 2 - 1) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleSimplexFractalRidgedMulti(double x, double y) {
            int seed = this.seed;
            double sum = 1 - Math.Abs(SingleSimplex(seed, x, y));
            double amp = 1;

            for (int i = 1; i < octaves; i++) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum -= (1 - Math.Abs(SingleSimplex(++seed, x, y))) * amp;
            }

            return sum;
        }

        public double GetSimplex(double x, double y) => SingleSimplex(seed, x * frequency, y * frequency);

        private const double F2 = 0.36602540378443864676372317075294;
        private const double G2 = 0.21132486540518711774542560974902;
        private const double H2 = G2 * 2;

        private static double SingleSimplex(int seed, double x, double y) {
            double t = (x + y) * F2;
            long i = LongFloor(x + t);
            long j = LongFloor(y + t);

            t = (i + j) * G2;
            double X0 = i - t;
            double Y0 = j - t;

            double x0 = x - X0;
            double y0 = y - Y0;

            long i1, j1;
            if (x0 > y0) {
                i1 = 1; j1 = 0;
            } else {
                i1 = 0; j1 = 1;
            }

            double x1 = x0 - i1 + G2;
            double y1 = y0 - j1 + G2;
            double x2 = x0 - 1 + H2;
            double y2 = y0 - 1 + H2;

            double n0, n1, n2;
            double t0 = 0.75 - x0 * x0 - y0 * y0;
            if (t0 > 0) {
                uint gi = Hash256(i, j, seed) << 1;
                t0 *= t0;
                n0 = t0 * t0 * (GRAD_2D[gi] * x0 + GRAD_2D[gi + 1] * y0);
            } else n0 = 0.0;

            double t1 = 0.75 - x1 * x1 - y1 * y1;
            if (t1 > 0) {
                uint gi = Hash256(i + i1, j + j1, seed) << 1;
                t1 *= t1;
                n1 = t1 * t1 * (GRAD_2D[gi] * x1 + GRAD_2D[gi + 1] * y1);
            } else n1 = 0.0;

            double t2 = 0.75 - x2 * x2 - y2 * y2;
            if (t2 > 0) {
                uint gi = Hash256(i + 1, j + 1, seed) << 1;
                t2 *= t2;
                n2 = t2 * t2 * (GRAD_2D[gi] * x2 + GRAD_2D[gi + 1] * y2);
            } else n2 = 0.0;

            return 9.11 * (n0 + n1 + n2);
        }

        public double GetSimplex(double x, double y, double z, double w) => SingleSimplex(seed, x * frequency, y * frequency, z * frequency, w * frequency);

        private static readonly byte[] SIMPLEX_4D =
        {
        0,1,2,3,0,1,3,2,0,0,0,0,0,2,3,1,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,0,
        0,2,1,3,0,0,0,0,0,3,1,2,0,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,1,3,2,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        1,2,0,3,0,0,0,0,1,3,0,2,0,0,0,0,0,0,0,0,0,0,0,0,2,3,0,1,2,3,1,0,
        1,0,2,3,1,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,1,0,0,0,0,2,1,3,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        2,0,1,3,0,0,0,0,0,0,0,0,0,0,0,0,3,0,1,2,3,0,2,1,0,0,0,0,3,1,2,0,
        2,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,2,0,0,0,0,3,2,0,1,3,2,1,0
    };

        private const double F4 = (2.23606797 - 1.0) / 4.0;
        private const double G4 = (5.0 - 2.23606797) / 20.0;

        private static double SingleSimplex(int seed, double x, double y, double z, double w) {
            double n0, n1, n2, n3, n4;
            double t = (x + y + z + w) * F4;
            int i = FastFloor(x + t);
            int j = FastFloor(y + t);
            int k = FastFloor(z + t);
            int l = FastFloor(w + t);
            t = (i + j + k + l) * G4;
            double X0 = i - t;
            double Y0 = j - t;
            double Z0 = k - t;
            double W0 = l - t;
            double x0 = x - X0;
            double y0 = y - Y0;
            double z0 = z - Z0;
            double w0 = w - W0;

            int c = (x0 > y0) ? 32 : 0;
            c += (x0 > z0) ? 16 : 0;
            c += (y0 > z0) ? 8 : 0;
            c += (x0 > w0) ? 4 : 0;
            c += (y0 > w0) ? 2 : 0;
            c += (z0 > w0) ? 1 : 0;
            c <<= 2;

            int ip = SIMPLEX_4D[c];
            int jp = SIMPLEX_4D[c + 1];
            int kp = SIMPLEX_4D[c + 2];
            int lp = SIMPLEX_4D[c + 3];

            int i1 = ip == 3 ? 1 : 0;
            int i2 = ip >= 2 ? 1 : 0;
            int i3 = ip >= 1 ? 1 : 0;
            int j1 = jp == 3 ? 1 : 0;
            int j2 = jp >= 2 ? 1 : 0;
            int j3 = jp >= 1 ? 1 : 0;
            int k1 = kp == 3 ? 1 : 0;
            int k2 = kp >= 2 ? 1 : 0;
            int k3 = kp >= 1 ? 1 : 0;
            int l1 = lp == 3 ? 1 : 0;
            int l2 = lp >= 2 ? 1 : 0;
            int l3 = lp >= 1 ? 1 : 0;

            double x1 = x0 - i1 + G4;
            double y1 = y0 - j1 + G4;
            double z1 = z0 - k1 + G4;
            double w1 = w0 - l1 + G4;
            double x2 = x0 - i2 + 2 * G4;
            double y2 = y0 - j2 + 2 * G4;
            double z2 = z0 - k2 + 2 * G4;
            double w2 = w0 - l2 + 2 * G4;
            double x3 = x0 - i3 + 3 * G4;
            double y3 = y0 - j3 + 3 * G4;
            double z3 = z0 - k3 + 3 * G4;
            double w3 = w0 - l3 + 3 * G4;
            double x4 = x0 - 1 + 4 * G4;
            double y4 = y0 - 1 + 4 * G4;
            double z4 = z0 - 1 + 4 * G4;
            double w4 = w0 - 1 + 4 * G4;

            t = 0.62 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
            if (t < 0) n0 = 0;
            else {
                t *= t;
                n0 = t * t * GradCoord4D(seed, i, j, k, l, x0, y0, z0, w0);
            }
            t = 0.62 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
            if (t < 0) n1 = 0;
            else {
                t *= t;
                n1 = t * t * GradCoord4D(seed, i + i1, j + j1, k + k1, l + l1, x1, y1, z1, w1);
            }
            t = 0.62 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
            if (t < 0) n2 = 0;
            else {
                t *= t;
                n2 = t * t * GradCoord4D(seed, i + i2, j + j2, k + k2, l + l2, x2, y2, z2, w2);
            }
            t = 0.62 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
            if (t < 0) n3 = 0;
            else {
                t *= t;
                n3 = t * t * GradCoord4D(seed, i + i3, j + j3, k + k3, l + l3, x3, y3, z3, w3);
            }
            t = 0.62 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
            if (t < 0) n4 = 0;
            else {
                t *= t;
                n4 = t * t * GradCoord4D(seed, i + 1, j + 1, k + 1, l + 1, x4, y4, z4, w4);
            }

            return 14.75 * (n0 + n1 + n2 + n3 + n4);
        }

        // Cubic Noise
        public double GetCubicFractal(double x, double y, double z) {
            x *= frequency;
            y *= frequency;
            z *= frequency;

            switch (fractalType) {
                case FractalType.FBM:
                    return SingleCubicFractalFBM(x, y, z);
                case FractalType.Billow:
                    return SingleCubicFractalBillow(x, y, z);
                case FractalType.Ridged:
                    return SingleCubicFractalRidgedMulti(x, y, z);
                default:
                    return 0;
            }
        }

        private double SingleCubicFractalFBM(double x, double y, double z) {
            int seed = this.seed;
            double sum = SingleCubic(seed, x, y, z);
            double amp = 1;
            int i = 0;

            while (++i < octaves) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum += SingleCubic(++seed, x, y, z) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleCubicFractalBillow(double x, double y, double z) {
            int seed = this.seed;
            double sum = Math.Abs(SingleCubic(seed, x, y, z)) * 2 - 1;
            double amp = 1;
            int i = 0;

            while (++i < octaves) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum += (Math.Abs(SingleCubic(++seed, x, y, z)) * 2 - 1) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleCubicFractalRidgedMulti(double x, double y, double z) {
            int seed = this.seed;
            double sum = 1 - Math.Abs(SingleCubic(seed, x, y, z));
            double amp = 1;
            int i = 0;

            while (++i < octaves) {
                x *= lacunarity;
                y *= lacunarity;
                z *= lacunarity;

                amp *= gain;
                sum -= (1 - Math.Abs(SingleCubic(++seed, x, y, z))) * amp;
            }

            return sum;
        }

        public double GetCubic(double x, double y, double z) => SingleCubic(seed, x * frequency, y * frequency, z * frequency);

        private const double CUBIC_3D_BOUNDING = 1 / (1.5 * 1.5 * 1.5);

        private static double SingleCubic(int seed, double x, double y, double z) {
            int x1 = FastFloor(x);
            int y1 = FastFloor(y);
            int z1 = FastFloor(z);

            int x0 = x1 - 1;
            int y0 = y1 - 1;
            int z0 = z1 - 1;
            int x2 = x1 + 1;
            int y2 = y1 + 1;
            int z2 = z1 + 1;
            int x3 = x1 + 2;
            int y3 = y1 + 2;
            int z3 = z1 + 2;

            double xs = x - x1;
            double ys = y - y1;
            double zs = z - z1;

            return CubicLerp(
                CubicLerp(
                CubicLerp(ValCoord3D(seed, x0, y0, z0), ValCoord3D(seed, x1, y0, z0), ValCoord3D(seed, x2, y0, z0), ValCoord3D(seed, x3, y0, z0), xs),
                CubicLerp(ValCoord3D(seed, x0, y1, z0), ValCoord3D(seed, x1, y1, z0), ValCoord3D(seed, x2, y1, z0), ValCoord3D(seed, x3, y1, z0), xs),
                CubicLerp(ValCoord3D(seed, x0, y2, z0), ValCoord3D(seed, x1, y2, z0), ValCoord3D(seed, x2, y2, z0), ValCoord3D(seed, x3, y2, z0), xs),
                CubicLerp(ValCoord3D(seed, x0, y3, z0), ValCoord3D(seed, x1, y3, z0), ValCoord3D(seed, x2, y3, z0), ValCoord3D(seed, x3, y3, z0), xs),
                ys),
                CubicLerp(
                CubicLerp(ValCoord3D(seed, x0, y0, z1), ValCoord3D(seed, x1, y0, z1), ValCoord3D(seed, x2, y0, z1), ValCoord3D(seed, x3, y0, z1), xs),
                CubicLerp(ValCoord3D(seed, x0, y1, z1), ValCoord3D(seed, x1, y1, z1), ValCoord3D(seed, x2, y1, z1), ValCoord3D(seed, x3, y1, z1), xs),
                CubicLerp(ValCoord3D(seed, x0, y2, z1), ValCoord3D(seed, x1, y2, z1), ValCoord3D(seed, x2, y2, z1), ValCoord3D(seed, x3, y2, z1), xs),
                CubicLerp(ValCoord3D(seed, x0, y3, z1), ValCoord3D(seed, x1, y3, z1), ValCoord3D(seed, x2, y3, z1), ValCoord3D(seed, x3, y3, z1), xs),
                ys),
                CubicLerp(
                CubicLerp(ValCoord3D(seed, x0, y0, z2), ValCoord3D(seed, x1, y0, z2), ValCoord3D(seed, x2, y0, z2), ValCoord3D(seed, x3, y0, z2), xs),
                CubicLerp(ValCoord3D(seed, x0, y1, z2), ValCoord3D(seed, x1, y1, z2), ValCoord3D(seed, x2, y1, z2), ValCoord3D(seed, x3, y1, z2), xs),
                CubicLerp(ValCoord3D(seed, x0, y2, z2), ValCoord3D(seed, x1, y2, z2), ValCoord3D(seed, x2, y2, z2), ValCoord3D(seed, x3, y2, z2), xs),
                CubicLerp(ValCoord3D(seed, x0, y3, z2), ValCoord3D(seed, x1, y3, z2), ValCoord3D(seed, x2, y3, z2), ValCoord3D(seed, x3, y3, z2), xs),
                ys),
                CubicLerp(
                CubicLerp(ValCoord3D(seed, x0, y0, z3), ValCoord3D(seed, x1, y0, z3), ValCoord3D(seed, x2, y0, z3), ValCoord3D(seed, x3, y0, z3), xs),
                CubicLerp(ValCoord3D(seed, x0, y1, z3), ValCoord3D(seed, x1, y1, z3), ValCoord3D(seed, x2, y1, z3), ValCoord3D(seed, x3, y1, z3), xs),
                CubicLerp(ValCoord3D(seed, x0, y2, z3), ValCoord3D(seed, x1, y2, z3), ValCoord3D(seed, x2, y2, z3), ValCoord3D(seed, x3, y2, z3), xs),
                CubicLerp(ValCoord3D(seed, x0, y3, z3), ValCoord3D(seed, x1, y3, z3), ValCoord3D(seed, x2, y3, z3), ValCoord3D(seed, x3, y3, z3), xs),
                ys),
                zs) * CUBIC_3D_BOUNDING;
        }


        public double GetCubicFractal(double x, double y) {
            x *= frequency;
            y *= frequency;

            switch (fractalType) {
                case FractalType.FBM:
                    return SingleCubicFractalFBM(x, y);
                case FractalType.Billow:
                    return SingleCubicFractalBillow(x, y);
                case FractalType.Ridged:
                    return SingleCubicFractalRidgedMulti(x, y);
                default:
                    return 0;
            }
        }

        private double SingleCubicFractalFBM(double x, double y) {
            int seed = this.seed;
            double sum = SingleCubic(seed, x, y);
            double amp = 1;
            int i = 0;

            while (++i < octaves) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum += SingleCubic(++seed, x, y) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleCubicFractalBillow(double x, double y) {
            int seed = this.seed;
            double sum = Math.Abs(SingleCubic(seed, x, y)) * 2 - 1;
            double amp = 1;
            int i = 0;

            while (++i < octaves) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum += (Math.Abs(SingleCubic(++seed, x, y)) * 2 - 1) * amp;
            }

            return sum * fractalBounding;
        }

        private double SingleCubicFractalRidgedMulti(double x, double y) {
            int seed = this.seed;
            double sum = 1 - Math.Abs(SingleCubic(seed, x, y));
            double amp = 1;
            int i = 0;

            while (++i < octaves) {
                x *= lacunarity;
                y *= lacunarity;

                amp *= gain;
                sum -= (1 - Math.Abs(SingleCubic(++seed, x, y))) * amp;
            }

            return sum;
        }

        public double GetCubic(double x, double y) {
            x *= frequency;
            y *= frequency;

            return SingleCubic(0, x, y);
        }

        private const double CUBIC_2D_BOUNDING = 1 / 2.25;

        private static double SingleCubic(int seed, double x, double y) {
            int x1 = FastFloor(x);
            int y1 = FastFloor(y);

            int x0 = x1 - 1;
            int y0 = y1 - 1;
            int x2 = x1 + 1;
            int y2 = y1 + 1;
            int x3 = x1 + 2;
            int y3 = y1 + 2;

            double xs = x - x1;
            double ys = y - y1;

            return CubicLerp(
                       CubicLerp(ValCoord2D(seed, x0, y0), ValCoord2D(seed, x1, y0), ValCoord2D(seed, x2, y0), ValCoord2D(seed, x3, y0),
                           xs),
                       CubicLerp(ValCoord2D(seed, x0, y1), ValCoord2D(seed, x1, y1), ValCoord2D(seed, x2, y1), ValCoord2D(seed, x3, y1),
                           xs),
                       CubicLerp(ValCoord2D(seed, x0, y2), ValCoord2D(seed, x1, y2), ValCoord2D(seed, x2, y2), ValCoord2D(seed, x3, y2),
                           xs),
                       CubicLerp(ValCoord2D(seed, x0, y3), ValCoord2D(seed, x1, y3), ValCoord2D(seed, x2, y3), ValCoord2D(seed, x3, y3),
                           xs),
                       ys) * CUBIC_2D_BOUNDING;
        }

        // Cellular Noise
        public double GetCellular(double x, double y, double z) {
            x *= frequency;
            y *= frequency;
            z *= frequency;

            switch (cellularReturnType) {
                case CellularReturnType.CellValue:
                case CellularReturnType.NoiseLookup:
                case CellularReturnType.Distance:
                    return SingleCellular(x, y, z);
                default:
                    return SingleCellular2Edge(x, y, z);
            }
        }

        private double SingleCellular(double x, double y, double z) {
            int xr = FastRound(x);
            int yr = FastRound(y);
            int zr = FastRound(z);

            double distance = 999999;
            int xc = 0, yc = 0, zc = 0;

            switch (cellularDistanceFunction) {
                case CellularDistanceFunction.Euclidean:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            for (int zi = zr - 1; zi <= zr + 1; zi++) {
                                Float3 vec = CELL_3D[Hash256(xi, yi, zi, seed)];

                                double vecX = xi - x + vec.x * cellularJitter;
                                double vecY = yi - y + vec.y * cellularJitter;
                                double vecZ = zi - z + vec.z * cellularJitter;

                                double newDistance = vecX * vecX + vecY * vecY + vecZ * vecZ;

                                if (newDistance < distance) {
                                    distance = newDistance;
                                    xc = xi;
                                    yc = yi;
                                    zc = zi;
                                }
                            }
                        }
                    }
                    break;
                case CellularDistanceFunction.Manhattan:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            for (int zi = zr - 1; zi <= zr + 1; zi++) {
                                Float3 vec = CELL_3D[Hash256(xi, yi, zi, seed)];

                                double vecX = xi - x + vec.x * cellularJitter;
                                double vecY = yi - y + vec.y * cellularJitter;
                                double vecZ = zi - z + vec.z * cellularJitter;

                                double newDistance = Math.Abs(vecX) + Math.Abs(vecY) + Math.Abs(vecZ);

                                if (newDistance < distance) {
                                    distance = newDistance;
                                    xc = xi;
                                    yc = yi;
                                    zc = zi;
                                }
                            }
                        }
                    }
                    break;
                case CellularDistanceFunction.Natural:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            for (int zi = zr - 1; zi <= zr + 1; zi++) {
                                Float3 vec = CELL_3D[Hash256(xi, yi, zi, seed)];

                                double vecX = xi - x + vec.x * cellularJitter;
                                double vecY = yi - y + vec.y * cellularJitter;
                                double vecZ = zi - z + vec.z * cellularJitter;

                                double newDistance = (Math.Abs(vecX) + Math.Abs(vecY) + Math.Abs(vecZ)) + (vecX * vecX + vecY * vecY + vecZ * vecZ);

                                if (newDistance < distance) {
                                    distance = newDistance;
                                    xc = xi;
                                    yc = yi;
                                    zc = zi;
                                }
                            }
                        }
                    }
                    break;
            }

            switch (cellularReturnType) {
                case CellularReturnType.CellValue:
                    return ValCoord3D(seed, xc, yc, zc);

                case CellularReturnType.NoiseLookup:
                    Float3 vec = CELL_3D[Hash256(xc, yc, zc, seed)];
                    return cellularNoiseLookup.GetNoise(xc + vec.x * cellularJitter, yc + vec.y * cellularJitter, zc + vec.z * cellularJitter);

                case CellularReturnType.Distance:
                    return distance;
                default:
                    return 0;
            }
        }

        private double SingleCellular2Edge(double x, double y, double z) {
            int xr = FastRound(x);
            int yr = FastRound(y);
            int zr = FastRound(z);

            double[] distance = { 999999, 999999, 999999, 999999 };

            switch (cellularDistanceFunction) {
                case CellularDistanceFunction.Euclidean:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            for (int zi = zr - 1; zi <= zr + 1; zi++) {
                                Float3 vec = CELL_3D[Hash256(xi, yi, zi, seed)];

                                double vecX = xi - x + vec.x * cellularJitter;
                                double vecY = yi - y + vec.y * cellularJitter;
                                double vecZ = zi - z + vec.z * cellularJitter;

                                double newDistance = vecX * vecX + vecY * vecY + vecZ * vecZ;

                                for (int i = cellularDistanceIndex1; i > 0; i--)
                                    distance[i] = Math.Max(Math.Min(distance[i], newDistance), distance[i - 1]);
                                distance[0] = Math.Min(distance[0], newDistance);
                            }
                        }
                    }
                    break;
                case CellularDistanceFunction.Manhattan:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            for (int zi = zr - 1; zi <= zr + 1; zi++) {
                                Float3 vec = CELL_3D[Hash256(xi, yi, zi, seed)];

                                double vecX = xi - x + vec.x * cellularJitter;
                                double vecY = yi - y + vec.y * cellularJitter;
                                double vecZ = zi - z + vec.z * cellularJitter;

                                double newDistance = Math.Abs(vecX) + Math.Abs(vecY) + Math.Abs(vecZ);

                                for (int i = cellularDistanceIndex1; i > 0; i--)
                                    distance[i] = Math.Max(Math.Min(distance[i], newDistance), distance[i - 1]);
                                distance[0] = Math.Min(distance[0], newDistance);
                            }
                        }
                    }
                    break;
                case CellularDistanceFunction.Natural:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            for (int zi = zr - 1; zi <= zr + 1; zi++) {
                                Float3 vec = CELL_3D[Hash256(xi, yi, zi, seed)];

                                double vecX = xi - x + vec.x * cellularJitter;
                                double vecY = yi - y + vec.y * cellularJitter;
                                double vecZ = zi - z + vec.z * cellularJitter;

                                double newDistance = (Math.Abs(vecX) + Math.Abs(vecY) + Math.Abs(vecZ)) + (vecX * vecX + vecY * vecY + vecZ * vecZ);

                                for (int i = cellularDistanceIndex1; i > 0; i--)
                                    distance[i] = Math.Max(Math.Min(distance[i], newDistance), distance[i - 1]);
                                distance[0] = Math.Min(distance[0], newDistance);
                            }
                        }
                    }
                    break;
                default:
                    break;
            }

            switch (cellularReturnType) {
                case CellularReturnType.Distance2:
                    return distance[cellularDistanceIndex1];
                case CellularReturnType.Distance2Add:
                    return distance[cellularDistanceIndex1] + distance[cellularDistanceIndex0];
                case CellularReturnType.Distance2Sub:
                    return distance[cellularDistanceIndex1] - distance[cellularDistanceIndex0];
                case CellularReturnType.Distance2Mul:
                    return distance[cellularDistanceIndex1] * distance[cellularDistanceIndex0];
                case CellularReturnType.Distance2Div:
                    return distance[cellularDistanceIndex0] / distance[cellularDistanceIndex1];
                default:
                    return 0;
            }
        }

        public double GetCellular(double x, double y) {
            x *= frequency;
            y *= frequency;

            switch (cellularReturnType) {
                case CellularReturnType.CellValue:
                case CellularReturnType.NoiseLookup:
                case CellularReturnType.Distance:
                    return SingleCellular(x, y);
                default:
                    return SingleCellular2Edge(x, y);
            }
        }

        private double SingleCellular(double x, double y) {
            int xr = FastRound(x);
            int yr = FastRound(y);

            double distance = 999999;
            int xc = 0, yc = 0;

            switch (cellularDistanceFunction) {
                default:
                case CellularDistanceFunction.Euclidean:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            Float2 vec = CELL_2D[Hash256(xi, yi, seed)];

                            double vecX = xi - x + vec.x * cellularJitter;
                            double vecY = yi - y + vec.y * cellularJitter;

                            double newDistance = vecX * vecX + vecY * vecY;

                            if (newDistance < distance) {
                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                            }
                        }
                    }
                    break;
                case CellularDistanceFunction.Manhattan:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            Float2 vec = CELL_2D[Hash256(xi, yi, seed)];

                            double vecX = xi - x + vec.x * cellularJitter;
                            double vecY = yi - y + vec.y * cellularJitter;

                            double newDistance = (Math.Abs(vecX) + Math.Abs(vecY));

                            if (newDistance < distance) {
                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                            }
                        }
                    }
                    break;
                case CellularDistanceFunction.Natural:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            Float2 vec = CELL_2D[Hash256(xi, yi, seed)];

                            double vecX = xi - x + vec.x * cellularJitter;
                            double vecY = yi - y + vec.y * cellularJitter;

                            double newDistance = (Math.Abs(vecX) + Math.Abs(vecY)) + (vecX * vecX + vecY * vecY);

                            if (newDistance < distance) {
                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                            }
                        }
                    }
                    break;
            }

            switch (cellularReturnType) {
                case CellularReturnType.CellValue:
                    return ValCoord2D(seed, xc, yc);

                case CellularReturnType.NoiseLookup:
                    Float2 vec = CELL_2D[Hash256(xc, yc, seed)];
                    return cellularNoiseLookup.GetNoise(xc + vec.x * cellularJitter, yc + vec.y * cellularJitter);

                case CellularReturnType.Distance:
                    return distance;
                default:
                    return 0;
            }
        }

        private double SingleCellular2Edge(double x, double y) {
            int xr = FastRound(x);
            int yr = FastRound(y);

            double[] distance = { 999999, 999999, 999999, 999999 };

            switch (cellularDistanceFunction) {
                default:
                case CellularDistanceFunction.Euclidean:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            Float2 vec = CELL_2D[Hash256(xi, yi, seed)];

                            double vecX = xi - x + vec.x * cellularJitter;
                            double vecY = yi - y + vec.y * cellularJitter;

                            double newDistance = vecX * vecX + vecY * vecY;

                            for (int i = cellularDistanceIndex1; i > 0; i--)
                                distance[i] = Math.Max(Math.Min(distance[i], newDistance), distance[i - 1]);
                            distance[0] = Math.Min(distance[0], newDistance);
                        }
                    }
                    break;
                case CellularDistanceFunction.Manhattan:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            Float2 vec = CELL_2D[Hash256(xi, yi, seed)];

                            double vecX = xi - x + vec.x * cellularJitter;
                            double vecY = yi - y + vec.y * cellularJitter;

                            double newDistance = Math.Abs(vecX) + Math.Abs(vecY);

                            for (int i = cellularDistanceIndex1; i > 0; i--)
                                distance[i] = Math.Max(Math.Min(distance[i], newDistance), distance[i - 1]);
                            distance[0] = Math.Min(distance[0], newDistance);
                        }
                    }
                    break;
                case CellularDistanceFunction.Natural:
                    for (int xi = xr - 1; xi <= xr + 1; xi++) {
                        for (int yi = yr - 1; yi <= yr + 1; yi++) {
                            Float2 vec = CELL_2D[Hash256(xi, yi, seed)];

                            double vecX = xi - x + vec.x * cellularJitter;
                            double vecY = yi - y + vec.y * cellularJitter;

                            double newDistance = (Math.Abs(vecX) + Math.Abs(vecY)) + (vecX * vecX + vecY * vecY);

                            for (int i = cellularDistanceIndex1; i > 0; i--)
                                distance[i] = Math.Max(Math.Min(distance[i], newDistance), distance[i - 1]);
                            distance[0] = Math.Min(distance[0], newDistance);
                        }
                    }
                    break;
            }

            switch (cellularReturnType) {
                case CellularReturnType.Distance2:
                    return distance[cellularDistanceIndex1];
                case CellularReturnType.Distance2Add:
                    return distance[cellularDistanceIndex1] + distance[cellularDistanceIndex0];
                case CellularReturnType.Distance2Sub:
                    return distance[cellularDistanceIndex1] - distance[cellularDistanceIndex0];
                case CellularReturnType.Distance2Mul:
                    return distance[cellularDistanceIndex1] * distance[cellularDistanceIndex0];
                case CellularReturnType.Distance2Div:
                    return distance[cellularDistanceIndex0] / distance[cellularDistanceIndex1];
                default:
                    return 0;
            }
        }

        public void GradientPerturb(ref double x, ref double y, ref double z) => SingleGradientPerturb(seed, gradientPerturbAmp, frequency, ref x, ref y, ref z);

        public void GradientPerturbFractal(ref double x, ref double y, ref double z) {
            int seed = this.seed;
            double amp = gradientPerturbAmp * fractalBounding;
            double freq = frequency;

            SingleGradientPerturb(seed, amp, frequency, ref x, ref y, ref z);

            for (int i = 1; i < octaves; i++) {
                freq *= lacunarity;
                amp *= gain;
                SingleGradientPerturb(++seed, amp, freq, ref x, ref y, ref z);
            }
        }

        private void SingleGradientPerturb(int seed, double perturbAmp, double frequency, ref double x, ref double y, ref double z) {
            double xf = x * frequency;
            double yf = y * frequency;
            double zf = z * frequency;

            int x0 = FastFloor(xf);
            int y0 = FastFloor(yf);
            int z0 = FastFloor(zf);
            int x1 = x0 + 1;
            int y1 = y0 + 1;
            int z1 = z0 + 1;

            double xs, ys, zs;
            switch (interp) {
                default:
                case Interp.Linear:
                    xs = xf - x0;
                    ys = yf - y0;
                    zs = zf - z0;
                    break;
                case Interp.Hermite:
                    xs = InterpHermiteFunc(xf - x0);
                    ys = InterpHermiteFunc(yf - y0);
                    zs = InterpHermiteFunc(zf - z0);
                    break;
                case Interp.Quintic:
                    xs = InterpQuinticFunc(xf - x0);
                    ys = InterpQuinticFunc(yf - y0);
                    zs = InterpQuinticFunc(zf - z0);
                    break;
            }

            Float3 vec0 = CELL_3D[Hash256(x0, y0, z0, seed)];
            Float3 vec1 = CELL_3D[Hash256(x1, y0, z0, seed)];

            double lx0x = Lerp(vec0.x, vec1.x, xs);
            double ly0x = Lerp(vec0.y, vec1.y, xs);
            double lz0x = Lerp(vec0.z, vec1.z, xs);

            vec0 = CELL_3D[Hash256(x0, y1, z0, seed)];
            vec1 = CELL_3D[Hash256(x1, y1, z0, seed)];

            double lx1x = Lerp(vec0.x, vec1.x, xs);
            double ly1x = Lerp(vec0.y, vec1.y, xs);
            double lz1x = Lerp(vec0.z, vec1.z, xs);

            double lx0y = Lerp(lx0x, lx1x, ys);
            double ly0y = Lerp(ly0x, ly1x, ys);
            double lz0y = Lerp(lz0x, lz1x, ys);

            vec0 = CELL_3D[Hash256(x0, y0, z1, seed)];
            vec1 = CELL_3D[Hash256(x1, y0, z1, seed)];

            lx0x = Lerp(vec0.x, vec1.x, xs);
            ly0x = Lerp(vec0.y, vec1.y, xs);
            lz0x = Lerp(vec0.z, vec1.z, xs);

            vec0 = CELL_3D[Hash256(x0, y1, z1, seed)];
            vec1 = CELL_3D[Hash256(x1, y1, z1, seed)];

            lx1x = Lerp(vec0.x, vec1.x, xs);
            ly1x = Lerp(vec0.y, vec1.y, xs);
            lz1x = Lerp(vec0.z, vec1.z, xs);

            x += Lerp(lx0y, Lerp(lx0x, lx1x, ys), zs) * perturbAmp;
            y += Lerp(ly0y, Lerp(ly0x, ly1x, ys), zs) * perturbAmp;
            z += Lerp(lz0y, Lerp(lz0x, lz1x, ys), zs) * perturbAmp;
        }

        public void GradientPerturb(ref double x, ref double y) => SingleGradientPerturb(seed, gradientPerturbAmp, frequency, ref x, ref y);

        public void GradientPerturbFractal(ref double x, ref double y) {
            int seed = this.seed;
            double amp = gradientPerturbAmp * fractalBounding;
            double freq = frequency;

            SingleGradientPerturb(seed, amp, frequency, ref x, ref y);

            for (int i = 1; i < octaves; i++) {
                freq *= lacunarity;
                amp *= gain;
                SingleGradientPerturb(++seed, amp, freq, ref x, ref y);
            }
        }

        private void SingleGradientPerturb(int seed, double perturbAmp, double frequency, ref double x, ref double y) {
            double xf = x * frequency;
            double yf = y * frequency;

            int x0 = FastFloor(xf);
            int y0 = FastFloor(yf);
            int x1 = x0 + 1;
            int y1 = y0 + 1;

            double xs, ys;
            switch (interp) {
                default:
                case Interp.Linear:
                    xs = xf - x0;
                    ys = yf - y0;
                    break;
                case Interp.Hermite:
                    xs = InterpHermiteFunc(xf - x0);
                    ys = InterpHermiteFunc(yf - y0);
                    break;
                case Interp.Quintic:
                    xs = InterpQuinticFunc(xf - x0);
                    ys = InterpQuinticFunc(yf - y0);
                    break;
            }

            Float2 vec0 = CELL_2D[Hash256(x0, y0, seed)];
            Float2 vec1 = CELL_2D[Hash256(x1, y0, seed)];

            double lx0x = Lerp(vec0.x, vec1.x, xs);
            double ly0x = Lerp(vec0.y, vec1.y, xs);

            vec0 = CELL_2D[Hash256(x0, y1, seed)];
            vec1 = CELL_2D[Hash256(x1, y1, seed)];

            double lx1x = Lerp(vec0.x, vec1.x, xs);
            double ly1x = Lerp(vec0.y, vec1.y, xs);

            x += Lerp(lx0x, lx1x, ys) * perturbAmp;
            y += Lerp(ly0x, ly1x, ys) * perturbAmp;
        }

    }
}